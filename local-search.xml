<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络知识点梳理（课内）</title>
    <link href="/2021/09/13/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/"/>
    <url>/2021/09/13/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h3><p>Computer network: a collection of autonomous computers interconnected by a single technology</p><ol><li><p>autonomous: be able to compute independently</p></li><li><p>interconnected: be able to exchange information</p></li></ol><p>Computer networks: collections of autonomous computers </p><p>​    例如：the Internet</p><p>Computer networks VS. Distributed systems:</p><ul><li>In distributed systems, a model on top of the network is used to present the independent computers to users as a single coherent system, e.g., the Web.</li><li>Who makes the decision?—- Users VS. OS</li></ul><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ul><li><p>按照传输技术</p><p>广播网络和点到点网络（单播）    Broadcast links and Point-to-point links</p></li><li><p>按照距离尺度</p><p>个域网、局域网、城域网、广域网和互联网</p><p>PAN        LAN        MAN        WAN</p></li></ul><h3 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h3><blockquote><p>本节需要掌握的内容包括：</p><p>1） 一组概念：对等体、协议、服务、接口、计算机网络体系结构、协议数据单元PDU、SDU；</p><p>2） 计算机网络协议分层的好处和缺点，通过协议分层实现数据封装及解封的过程；</p><p>3） 面向连接服务和面向无连接服务的特点及实现过程；</p><p>4） 面向连接与面向无连接VS.可靠与不可靠</p></blockquote><ol><li><p>服务：层间交换信息时必须遵守的规则。</p></li><li><p>接口：定义了下层向上层提供的原语操作和服务。</p></li><li><p>第N层协议：</p><ul><li><p>不知道上、下层的内部结构</p></li><li><p>独立完成某种功能</p></li><li><p>为上层提供服务</p></li><li><p>使用下层提供的服务</p></li></ul></li></ol><p><em>说人话就是上一层通过接口收到下一层送上门来的东西（大雾）</em></p><hr><p>有个具体的生活中的例子作为类比：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914000941.png" alt="哲学家-翻译-秘书层级"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914001218.png" alt="协议分层"></p><ol><li><p>同一层级的通信，即水平通信（也是peer-to-peer的），属于虚拟通信</p></li><li><p>相邻层的通信是实际通信</p></li></ol><p><strong>一些概念：</strong></p><ul><li><p>服务访问点SAP（Service Access Point）</p><p>任何层间服务是在接口的SAP上进行的，每个SAP有唯一的识别地址</p><p>每个层间接口可以有多个SAP </p></li><li><p>接口数据单元IDU（Interface Data Unit）</p><p>IDU是通过SAP进行传送的层间信息单元</p><p>IDU由上层的服务数据单元SDU（Service Data Unit）和接口控制信息ICI（Interface Control Information）组成</p></li><li><p>协议数据单元PDU（Protocol Data Unit）</p><p>第N层实体通过网络传送给它的对等实体的信息单元</p><p>PDU由上层的服务数据单元SDU或其分段和协议控制信息PCI（Protocol Control Information）组成</p></li><li><p>服务数据单元SDU（Service Data Unit）</p><p>跨过网络传给对等实体并交给上层的信息</p></li></ul><blockquote><p>SDU（service Data Unit）:服务数据单元，又叫业务数据单元，是指定层的用户服务的数据集，传送到接收方的时候同一协议层时数据没有发生变化，即业务部分，然后发给下层之后，下层将其封装在PDU中发送出去。服务数据单元是从高层协议来的信息单元传送到低层协议。第N层服务数据单元SDU，和上一层的协议数据单元（PDU）是一一对应的。根据协议数据单元的数据的不同，送到接收端的指定层。</p><p>PDU（Protocol data unit）: 协议数据单元：<strong>计算机网络各层对等实体间交换的单位信息</strong>，例如TCP层的PDU就是segment（分节）、应用层间交换的PDU则是application data（应用数据）</p><p>转自： <a href="http://blog.csdn.net/wind19/article/details/4669637">http://blog.csdn.net/wind19/article/details/4669637</a></p></blockquote><p>存在公式：</p><p>PDU(N) = SDU(N - 1)</p><p>SDU(N) = PDU(N + 1)</p><p>对于某一层来说，收到的是SDU;</p><p>处理完出去的是PDU，那么对于下一层来说，这块PDU就是下一层的SDU</p><blockquote><p>N层用户与N层协议之间传递的数据称为服务数据单元(SDU)<br>N层协议实体之间传递的数据称为协议数据单元（PDU），通过数据发送/接收管理把用户提交的SDU以PDU的形式，通过下层通道发送到对端协议实体。在接收端再将PDU还原成SDU送给收端用户。<br>PDU的封装/解封装：在发送方，将用户递交的SDU加上协议控制信息PCI，封装成PDU；在接收方，讲接收到的PDU解封装，去掉PCI，还原成SDU送交接收方用户。<br>SDU分段/装配 ：如果下层通道的带宽不能满足传递SDU的需要，就需要将一个SDU分成多段，分别封装成PDU发送出去（分段）；在接收方再将这些PDU解封装后重新装配成SDU。<br>SDU拼接/分离：拼接是指在发送方(n)层协议实体把多个长度较短的(n)SDU封装成一个(n)PDU来发送，在接收放再将接收到的(n)PDU解封装，将多个(n)SDU分离出来。采用拼接功能的目的是提高通道的利用率。<br>PDU分割/组合：PDU分割是指在发送端(n)层协议实体把一个(n)PDU分割成多个(n-1)SDU，并行地从多个(n-1)通道发送出去；接收端再将收到的多个(n- 1)SDU组合成一个(n)PDU。由于这是一个N层功能，所以组合操作在N层中进行，即N层先得到多个分割开的(n)PDU，然后把它们组合成一个(n)PDU。</p><p>转自：<a href="https://blog.csdn.net/zhangxiao93/article/details/51253933">(52条消息) 网络通信PDU和SDU的区别_上善若水-CSDN博客_pdu sdu</a></p></blockquote><p>简而言之，一个SDU可能要封装在多个PDU中传输，    N层的PDU = N层的PCI + N层的SDU</p><hr><p><strong>网络协议分层的优缺点：</strong></p><ul><li>缺点：层次多，效率低</li><li>优点：层次间相互独立，无需知道相邻层次的具体完成细节；模块化维护方便，只需要接口、提供的service不变就可以；也容易进行复用。</li></ul><blockquote><p>Stanford CS144:</p><ol><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Separation of concerns</li><li>Continuous improvement</li><li>Peer-to-peer communications （eg. the Internet 使用互联网不需要考虑如何实现通信）</li></ol></blockquote><p><strong>面向连接和面向无连接</strong> &amp; <strong>可靠与不可靠</strong></p><p>见中文书本P27-29</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151244.png" style="zoom:80%;" /><hr><h3 id="服务与协议的关系"><a href="#服务与协议的关系" class="headerlink" title="服务与协议的关系"></a>服务与协议的关系</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151621.png" alt="书本P36 服务 vs. 协议" style="zoom:80%;" /><hr><h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p>博客园上有老哥做了一个OSI七层 和 TCP/IP五层模型的小总结，写的还不错</p><p>链接：<a href="https://www.cnblogs.com/qishui/p/5428938.html">OSI七层模型与TCP/IP五层模型 - SevenFormer - 博客园 (cnblogs.com)</a></p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151739.png" style="zoom:60%;" /><p>——<em>上图需要注意通信子网协议边界，路由涉及到第三层，交换机涉及到第二层</em>——–</p><ol><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p><p>用户需要的各种各样的协议，例如HTTP（超文本传输协议）</p></li></ol><h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4><ol><li><p>链路层</p><ul><li>该层描述了链路必须完成什么功能，才能满足无连接的互联网络层的需求，比如串行线和经典以太网链路</li><li>这不是真正意义上的一个层，而是主机和传输线路的一个接口</li></ul></li><li><p>互联网层</p><ul><li>大致对应OSI网络层，该层任务是允许主机将数据包注入到任何网络，让这些数据包独立到达接收方（也许接收方在不同的网络上）（数据包到达顺序和发送顺序也可能不一）</li><li>这里的internet是指一般意义上的互联网络，非现在所说的<em>互联网</em>。</li><li>该层定义了官方数据包格式和协议，即IP协议，还有辅助协议因特网控制报文协议ICMP，该层还需要考虑拥塞控制问题（Congestion Control）</li></ul></li><li><p>传输层</p><ul><li>允许源主机和目标主机的对等实体进行对话，如同OSI传输层</li><li>定义有两个端到端的传输协议，分别是传输控制协议TCP 和 用户数据报协议 UDP</li></ul><p><strong>TCP:</strong></p><p>可靠、面向连接；还负责流量控制（接收方和发送方）；将输入的字节流分割成离散的报文，再传递给互联网层；在目标机器，接收TCP进程会把收到的报文重新装配到输出流中。（生活实际：下载文件）</p><p><strong>UDP:</strong></p><p>不可靠、无连接协议；广泛应用于一次性的客户机-服务器类型的“请求-应答”查询应用，以及<strong>及时交付</strong>更为重要的应用（比如传输语音或视频）</p></li><li><p>应用层</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154219.png" style="zoom:60%;" /></li></ol><h4 id="两种模型的共同点和不同点"><a href="#两种模型的共同点和不同点" class="headerlink" title="两种模型的共同点和不同点"></a>两种模型的共同点和不同点</h4><p><strong>共同点：</strong></p><ul><li>以协议栈概念为基础；协议栈中协议彼此独立；层功能大致相似</li></ul><p><strong>不同点：</strong></p><ul><li>OSI模型核心：服务；接口；协议。</li></ul><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154914.png" alt="书本P38" style="zoom:60%;" /><ul><li><p>TCP/IP模型最初并没有明确区分以上三个概念；所以OSI的协议更有隐蔽性，协议更容易被替换</p></li><li><p>OSI由于没有考虑网络互连的问题，推行不是很方便；TCP/IP模型非常切合其本身协议，但其他协议栈不支持</p></li><li><p>最明显的就是层数不同……</p></li><li><p>OSI的网络层同时支持无连接和面向连接的通信，传输层只支持面向连接的通信；这由该层的特点所决定，因为传输服务对于用户可见</p></li><li><p>TCP/IP在网络层只支持无连接，传输层支持两种通信模式（TCP and UDP )，可以给用户选择的机会，对于简单的“请求-应答”协议特别重要</p></li></ul><p><strong>两种模型的评价</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155624.png" style="zoom:55%;" /><hr><h3 id="网络标准化"><a href="#网络标准化" class="headerlink" title="网络标准化"></a>网络标准化</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155751.png" style="zoom:60%;" />]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>课内复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP-动态规划学习（1）</title>
    <link href="/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <url>/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划学习（1）"><a href="#动态规划学习（1）" class="headerlink" title="动态规划学习（1）"></a>动态规划学习（1）</h1><p>我这个铁fw直到要大二了，才开始着手算法部分的复习（其实是学习QAQ）</p><hr><h2 id="动态规划的思考方法"><a href="#动态规划的思考方法" class="headerlink" title="动态规划的思考方法"></a>动态规划的思考方法</h2><p>这一方法来自于AcWing社区的创始人yxc，是y总特别教学的dp问题分析大法</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>例题：AcWing 02，下附链接</p><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><p><strong>题目描述</strong></p><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; N,V &lt;= 1000;    0&lt; Vi , Wi &lt;= 1000;</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改进为一维后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= v[i]; j --)<span class="hljs-comment">//这边进行了一个逆向</span><br>        &#123;<br>        <span class="hljs-comment">//    f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//    if(j &gt;= v[i])</span><br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1≤N,M≤1000</p><p><strong>输入样例</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">abcd</span><br><span class="hljs-attribute">abedc</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h4 id="codes-1"><a href="#codes-1" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">char</span> a[N];<br><span class="hljs-keyword">char</span> b[N];<br><span class="hljs-keyword">int</span> n , m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; a+<span class="hljs-number">1</span> &gt;&gt; b+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m ; j ++)<br>       &#123;<br>       f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span>(a[i] == b[j])<br>           f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大写字母。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少操作次数。</p><p><strong>数据范围</strong></p><p>1≤n,m≤1000</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">10 <br>AGTCTGACGC<br>11 <br>AGTAAGTAGGC<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithms</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(4)</title>
    <link href="/2021/08/28/2021-08-28-CPP-OPP-review(4)/"/>
    <url>/2021/08/28/2021-08-28-CPP-OPP-review(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-4"><a href="#CPP-OPP-review-4" class="headerlink" title="CPP-OPP review(4)"></a>CPP-OPP review(4)</h1>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(3)</title>
    <link href="/2021/07/22/2021-07-20-CPP-OPP-review(3)/"/>
    <url>/2021/07/22/2021-07-20-CPP-OPP-review(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-3"><a href="#CPP-OPP-review-3" class="headerlink" title="CPP-OPP review(3)"></a>CPP-OPP review(3)</h1><p>A <strong>BIG THREE</strong>:</p><ol><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>析构 </li></ol><p>有指针成员的函数，必须要有拷贝构造+拷贝赋值  </p><p>否则就产生多重引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __MYSTRING__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __MYSTRING__</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:                                 <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr=<span class="hljs-number">0</span>);                     <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);                    <br>   String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);         <br>   ~<span class="hljs-built_in">String</span>();                                    <br>   <span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (cstr) &#123;<br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//动态分配内存， +1因为包括结束符</span><br>      <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;   <br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];<br>      *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//注意这里是*m_data</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//注意这里是delete[]，而不是delete</span><br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<span class="hljs-comment">//拷贝赋值</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//&amp;符号的含义结合具体情况，加在类型后面就是引用，</span><br>       <span class="hljs-comment">//如果加在变量名前，就是取地址</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这种情况检验自我赋值。例如s1 = s1;</span><br>    <span class="hljs-comment">//特殊情况特殊处理</span><br><br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//先delete，再分配空间+拷贝</span><br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String&amp; str)</span><span class="hljs-comment">//拷贝构造</span></span><br><span class="hljs-function"></span>&#123;<br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br>   os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();<br>   <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723231933.png" alt="构造函数 和 析构函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232041.png" alt="拷贝构造"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232232.png" alt="拷贝赋值函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232327.png" alt="自我赋值造成可能的危险"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232632.png" alt="new 申请空间"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232713.png" alt="delete 释放空间"></p><p><code>new</code>实际上先申请了一部分内存，在进行构造</p><p><code>delete</code>则反过来，先调用析构函数，再释放内存</p><hr><p>接下来是底层的内存分配示意图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233051.png"></p><p>红色部分是 <em>cookie</em>，各占四个字节；灰色部分是 <em>debugger header</em>，以及<em>no man land</em>，当然还有内存对齐所需要的空间。    从52到64，是为了让申请的内存块大小达到16Byte的倍数。</p><p>之后的图片说明了，<code>delete</code>和<code>delete[]</code>的区别：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233633.png" alt="delete的使用"></p><p>确实会造成<strong>memory leak</strong>，但其实是打<strong>？！</strong>的内存区域没有被回收，而不是想象中的<strong>21h</strong>部分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(2)</title>
    <link href="/2021/07/20/2021-07-20-CPP-OPP-review(2)/"/>
    <url>/2021/07/20/2021-07-20-CPP-OPP-review(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-2"><a href="#CPP-OPP-review-2" class="headerlink" title="CPP-OPP review(2)"></a>CPP-OPP review(2)</h1><ol><li><p>操作符重载，可分为：<strong>成员函数</strong>（含<code>this</code>指针）和<strong>非成员函数</strong>。</p></li><li><p>临时对象，例如之前所写的<code>complex</code>类,<code>complex(2,1)</code>创建一个**2 + i *<em>的复数临时对象。如果在成员函数当中被临时创建，注意使用</em>return by value*, 因为在函数中创建的对象是 <em>local</em> 的，临时的。</p></li><li><p>输入输出流作为参数不可以作为<code>const</code>传入</p></li><li><p>一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么返回的是<code>ostream&amp;</code>，而不是<code>void</code>？</p><p>因为很常见的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; c1;<span class="hljs-comment">//void 还是ostream&amp;返回 都可以</span><br>cout &lt;&lt; c1 &lt;&lt; c2;<span class="hljs-comment">//假设是这种情况，void返回就不行。</span><br></code></pre></td></tr></table></figure><hr></li></ol><p><strong>总结</strong></p><p><strong>initialization list</strong>的使用；函数参数考虑，尽量用<em>pass_by_reference</em>；函数参数考虑是否要加<code>const</code>；函数返回值考虑是否用<em>pass_by_reference</em>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(1)</title>
    <link href="/2021/07/18/2021-07-18-CPP-0PP-review(1)/"/>
    <url>/2021/07/18/2021-07-18-CPP-0PP-review(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-1"><a href="#CPP-OPP-review-1" class="headerlink" title="CPP-OPP review(1)"></a>CPP-OPP review(1)</h1><p>这个<em>review</em>系列是本人观看侯捷老师的面向对象的讲解视频，并结合 <em>effective C++</em> 这本经典书籍，进行的一些知识点的零散记录。</p><hr><ol><li><p>class中的成员函数，默认成为<code>inline</code>函数的候选</p></li><li><p>外部的函数想要成为<code>inline</code>，需要加关键字<code>inline</code></p></li><li><p>构造函数的写法：</p><ol><li><p>赋值写法</p></li><li><p>运用<strong>初值列</strong>(<em>initialization list</em>),进行初始化</p><p>这两种的区别是，构造函数先进行初始化，再进行{}内部的操作，用<em>initialization list</em>更有效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re, im;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>构造函数允许有很多个 - <strong>overloading</strong></p><p><em>但如果出现以下的例子，则not allowed</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<span class="hljs-comment">//这里不需要加分号了</span><br><span class="hljs-built_in">complex</span>():<span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>)&#123;&#125;<span class="hljs-comment">//与上面一个构造函数冲突</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">double</span> re, im;<br></code></pre></td></tr></table></figure></li><li><p>构造函数也有可能写在<code>private</code>中，这种模式叫做<em>singleton</em>.</p></li><li><p>在写成员函数的时候，就需要考虑好，是否需要加上<code>const</code>.<strong>该加上就要加上！</strong></p></li><li><p>尽可能多用<em>pass-by-reference</em>，pass-by-value(to const)需要将数据 <em>打包</em> 压入栈，（可能爆栈）</p></li><li><p>相同<code>class</code>的各个对象互为友元，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex &amp;pra)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (pra.re + pra.im);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re , im;<br>&#125;;<br><br><span class="hljs-comment">//////////以下为main函数///////</span><br>&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    c2.<span class="hljs-built_in">func</span>(c1);<span class="hljs-comment">//实部虚部相加 </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/12_随记</title>
    <link href="/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-12-随记"><a href="#CPP-面向对象-21-7-12-随记" class="headerlink" title="CPP 面向对象 21/7/12 随记"></a>CPP 面向对象 21/7/12 随记</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>使用了<code>new</code>或指针的相同类或结构体的对象间，不能使用 = 进行赋值操作，必须对 = 进行了操作符重载后，才能赋值。否则两个类的指针指向相同的内存地址。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>分为<code>public</code>继承和<code>private</code>继承 （还有<code>protected</code>继承）</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210713082837.png"></p><p>派生类的访问权限由基类+继承类型 <em>取小</em> 得到。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超频一时爽，系统崩溃死机火葬场</title>
    <link href="/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/"/>
    <url>/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="这周末的作死，让我对OverClock产生了阴影……"><a href="#这周末的作死，让我对OverClock产生了阴影……" class="headerlink" title="这周末的作死，让我对OverClock产生了阴影……"></a>这周末的作死，让我对OverClock产生了阴影……</h1><p>另外自己也不应该买es的CPU，在bios自检不通过的情况下，也没有妥善处理。</p><p>感谢msi，感谢Intel，感谢巨硬。也感谢    <strong>自己作大死！</strong></p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/8_随记</title>
    <link href="/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-07-08"><a href="#CPP-面向对象-21-07-08" class="headerlink" title="CPP 面向对象  21/07/08"></a>CPP 面向对象  21/07/08</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ol><li><p> <code>enum</code> <strong>枚举类型变量</strong></p></li><li><p><code>struct</code><strong>类型</strong></p><p>对于<code>struct</code>整体进行操作，可行的有：</p><ol><li>给同一<code>struct</code>类型的对象赋值（值传递或引用传递）</li><li>作为函数参数返回</li></ol></li><li><p><code>class</code><strong>类型</strong></p><ol><li><p>该类型中有两种成员： 数据成员 和 函数成员</p></li><li><p>成员默认为<code>private</code>，这一点和<code>struct</code>类型不同</p></li><li><p>函数成员大多应该声明为public类型</p></li><li><p><code>private</code>类型成员无法被外部访问，只能被该<code>class</code>成员函数 和 友元 访问</p></li><li><p>（默认）构造函数</p></li></ol></li></ol><hr><p><em>以下更新于2021.7.9</em></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><blockquote><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><p>内联函数一般用于能够快速执行的函数，对于很小的函数也有空间上的溢出。</p><p>内联函数是在函数原型的前面加上<code>inline</code>限定符, 例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt; y)?x:y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(20,10): &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(100,1010)： &quot;</span>&lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1010</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><p>内联函数是为了解决函数调用的效率问题。编译的时候，调用式用函数体进行替换；而其他的函数都是在运行的时候才被替代。    故实际上是通过<strong>空间换时间</strong>。以下有几个注意点：</p><ol><li>循环语句，开关语句不允许出现</li><li>内联函数的定义，需要出现在函数第一次调用之前</li><li>类结构中所在的类说明内部定义的函数是内联函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++》 阅读随记</title>
    <link href="/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读《Effective-C-》第一章"><a href="#读《Effective-C-》第一章" class="headerlink" title="读《Effective C++》第一章"></a>读《Effective C++》第一章</h1><h2 id="C-是一个语言联邦"><a href="#C-是一个语言联邦" class="headerlink" title="C++是一个语言联邦"></a>C++是一个语言联邦</h2><p>C++是一个多重范型(muitiparidigm)语言，其支持：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>次语言(sublanguage)：C, Object-Oriented C++, Template C++, STL</p><p>正因如此，高效编程需要随着编程者切换次语言来采取不同的守则、通例。</p><h2 id="用-const-enum-inline-替换-define"><a href="#用-const-enum-inline-替换-define" class="headerlink" title="用 const enum inline 替换 #define"></a>用 <code>const</code> <code>enum</code> <code>inline</code> 替换 <code>#define</code></h2><ol><li><p>对于常量</p><p>例如：<code>#define ASPECT_RATIO 1.653</code> 该记号名称也许从未被编译器看见，很可能在编译器处理源码之前，就被预处理器移走。这样的后果：ASPECT_RATIO 有可能未进入 symbol table （<em><strong>注：符号表等概念可以查阅CSAPP第七章</strong></em>）。于是一旦发生编译错误，可能就因此让编程者产生困惑。</p><p>解决方法：用常量替换一个上述的宏</p></li></ol><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708142830.png" style="zoom:80%;" /><p>​        两种特殊情况：</p><p>​        <strong>常量指针</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143130.png" style="zoom:80%;" /><p>​        <strong><code>class</code>专属常量</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143415.png" style="zoom:80%;" /><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143755.png" style="zoom:80%;" /><p>​        <strong>enum hack</strong> 技术，能够避免出现可能的（编译器不够优秀）为“整数型const对象” 进行内存分配</p><p>​        <strong>enum hack</strong> 技术，是模板元编程的基础技术。</p><ol start="2"><li>用<code>inline</code> 替代macro</li></ol><p>（暂时略……）</p><p><strong>总结</strong></p><blockquote><p>对于单纯常量，最好以const对象 或 enum 替换 #define</p><p>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</p></blockquote><h2 id="尽可能使用-const"><a href="#尽可能使用-const" class="headerlink" title="尽可能使用 const"></a>尽可能使用 <code>const</code></h2><p><code>const</code>关键字允许指定一个语义约束（说人话就是指定一个改动不了的对象）</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190027.png"></p><p><strong><code>const</code> 若出现在星号左边，表示被指物为常量；在星号右边，表示指针是常量；如果星号两边都有<code>const</code>,说明被指对象和指针本身都是常量。</strong></p><p>注：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190839.png"></p><hr><p>对于STL迭代器的<code>const</code>，和命名指针(T类型的指针, <code>T*</code>)类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// iter的作用类似于 T* const</span><br><span class="hljs-comment">//指向的东西必须一样，但东西的值可以改变</span><br>*iter = <span class="hljs-number">10</span>;<span class="hljs-comment">//ok</span><br>iter ++;<span class="hljs-comment">//not allowed</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// cIter的作用类似于 const T*  </span><br><span class="hljs-comment">//被指向的东西不得改变</span><br>*cIter = <span class="hljs-number">10</span>;<span class="hljs-comment">//not allowed</span><br>cIter ++;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>令函数返回一个常量值，往往可以能够降低因client端的错误而造成的意外。详细例子见书P19</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>这类函数重要，原因有两个：</p><ol><li><p>让class接口更好理解，client端知道哪个函数可以改变对象内容，而哪个不行。</p></li><li><p>让操作<code>const</code>对象成为可能，因为提升C++程序效率的一条原则：<em><strong>pass by reference to const</strong></em></p><p>这技术可行的前提：有<code>const</code>成员函数用来处理取得的<code>const</code>对象</p></li></ol><p>一个事实：如果两个函数只是常量性不同，可以被重载。</p><p>如图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215257.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215407.png"></p><p>因为<code>non-const operator[]</code>的返回类型是<strong>reference to char</strong>，不是<code>char</code>；如果返回的是<code>char</code>，该语句无法通过编译。因为函数如果返回类型是内置类型（如<code>int</code>,<code>char</code>,<code>bool</code>）, 改动返回值就是不合法的。</p><hr><p>还有两个概念<strong>logical constness</strong> 和 <strong>bitwise constness</strong> </p><p>后者支持者认为成员函数只有在不改变认为成员变量（除静态<code>static</code>变量以外）的情况下，才可以被称为<code>const</code>.</p><p>也就是不改动任何一个<strong>bit</strong>. 但却有很多函数符合该规则，却不是十足具备<code>const</code>性质，如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220107.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220127.png"></p><p>另一派支持：**<code>const</code>成员函数可以修改对象的某些bits，但要在客户端侦测不到的时候才得如此。**</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220438.png"></p><p>重要： <strong>用<code>mutable</code>“骗过”编译器</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220501.png"></p><h3 id="在const-和-non-const成员函数中避免重复"><a href="#在const-和-non-const成员函数中避免重复" class="headerlink" title="在const 和 non-const成员函数中避免重复"></a>在const 和 non-const成员函数中避免重复</h3><p><em>暂时略……反正<code>const</code>很强就完事了……</em></p><p><strong>总结：</strong></p><blockquote><p>将有些东西声明为<code>const</code>可以帮助编译器侦测出错误用法。 <code>const</code>可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><p>编译器强制实施 <strong>bitwise constness</strong>, 但实际编写程序应该使用“概念上的常量性”（比如使用mutable）</p><p>用<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>版本调用<code>const</code>版本可避免代码的重复。</p></blockquote><h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>《Effective C++》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/7_随记</title>
    <link href="/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-7"><a href="#CPP-面向对象-21-7-7" class="headerlink" title="CPP 面向对象 21/7/7"></a>CPP 面向对象 21/7/7</h1><h2 id="库-lt-fstream-gt-的使用，文件输入输出"><a href="#库-lt-fstream-gt-的使用，文件输入输出" class="headerlink" title="库&lt;fstream&gt;的使用，文件输入输出"></a>库<code>&lt;fstream&gt;</code>的使用，文件输入输出</h2><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-comment">/*...省略其余头文件...*/</span><br><br><span class="hljs-keyword">double</span> a;<br>string b;<br><span class="hljs-comment">//需要读入的变量</span><br><br>ifstream inFile;<br>ofstream outFile;<br><br>inFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;INPUT.txt&quot;</span>);<span class="hljs-comment">//此处为相对路径</span><br>outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;result.txt&quot;</span>);<span class="hljs-comment">//结果输出到 result.txt 文件中</span><br><br>inFile &gt;&gt; a &gt;&gt; b;<span class="hljs-comment">//读入</span><br><span class="hljs-comment">//同理输出到文件用outFile</span><br><br><span class="hljs-comment">/*关于文件流的使用，可以用 inFile,outFile 代替原有的 cin,cout*/</span><br><br>inFile.<span class="hljs-built_in">close</span>();<br>outFile.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭流</span><br><br><br></code></pre></td></tr></table></figure><p>如果输入流打开的文件有误（读取不合法，或文件路径错误等等），会产生输入流的挂起。这种情况在编写程序的时候需要特判    如<code>if(!inFile)  return 1;</code></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Don&#39;t program with COINCIDENCE.</title>
    <link href="/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/"/>
    <url>/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/6_随记</title>
    <link href="/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-6"><a href="#CPP-面向对象-21-7-6" class="headerlink" title="CPP 面向对象 21/7/6"></a>CPP 面向对象 21/7/6</h1><h2 id="C-语法知识"><a href="#C-语法知识" class="headerlink" title="C++语法知识"></a>C++语法知识</h2><p><strong>格式化输出setw(), setprecision()应用</strong></p><p>setw() 默认右对齐</p><p>eg. s和a之间有7个空格，cout&lt;&lt;’s’&lt;&lt;setw(8)&lt;&lt;’a’&lt;&lt;endl;的意思是s后面输出8个字符，其中a占一个字符，剩余7个字符用空格填充</p><p>setw()默认用空格填充，也可以用其他的字符填充，运用setfill()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">21</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706102918153.png"></p><p>如果需要左对齐，则在前面添加left，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &lt;&lt;  <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706104131423.png"></p><hr><p>setprecision() + fixed 控制精确到小数点后的位数</p><p><em><strong>补充：setfill()函数会永久更改填充空格的字符，下次重新用的时候注意初始化为所用的符号（默认的setw()填充为空格）</strong></em></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>类具有封装和信息隐藏的特性。只有<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">类的成员函数</a>才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a>，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。 </p><p>为了解决上述问题，提出一种使用友元的方案。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。(from baidu)</p></blockquote><ol><li><strong>友元函数</strong></li></ol><p>友元是定义在类外部的普通函数或类，但需要在<em><strong>类体中</strong></em>进行说明，用<code>friend</code>关键字加以说明。故友元函数的调用不需要对象表示，直接调用即可。</p><p>友元函数没有this指针，其参数分几种情况：</p><p>访问非static变量，需要对象作为参数；访问static成员或全局变量时，不需要对象做参数。</p><ol start="2"><li><strong>友元类</strong></li></ol><blockquote><p>友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的<a href="https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a>，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p></blockquote><p>格式：</p><p><code>friend class  </code> + 类名</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706131141197.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
