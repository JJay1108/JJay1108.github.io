<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 使用clash代理</title>
    <link href="/2022/03/29/2022-03-29-Linux-%E4%BD%BF%E7%94%A8clash%E4%BB%A3%E7%90%86/"/>
    <url>/2022/03/29/2022-03-29-Linux-%E4%BD%BF%E7%94%A8clash%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux如何使用clash服务？"><a href="#Linux如何使用clash服务？" class="headerlink" title="Linux如何使用clash服务？"></a>Linux如何使用clash服务？</h1><p>继上次随手写了篇关于Linux虚拟机如何使用clash代理的服务之后，</p><p>我大概在寒假结束前的一个礼拜（我隔了一个月才写）探索出了Linux虚拟机直接使用clash服务的方法（而不是以前用那种Host主机开启LAN的方法……那种方法多少有点残废，且网速很堪忧）</p><h2 id="第一种，直接下载config文件并使用"><a href="#第一种，直接下载config文件并使用" class="headerlink" title="第一种，直接下载config文件并使用"></a>第一种，直接下载config文件并使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://....<br></code></pre></td></tr></table></figure><p>wget+相应链接即可。</p><p>如果没有安装<code>wget</code>，需要输入：<code>sudo apt install wget</code></p><p>之后输入<code>./clash -d .</code></p><p>如果发现输出的不是<code>starting download MMDB</code>，而是输出什么<code>start listening mixed port 9090</code>(<em>注，这里指的是第一次使用clash</em>)</p><p>这里可惜现在当前路径下输入<code>ls</code>查看当前目录下的文件，如果有<code>config.yaml</code>和<code>config.yml</code>文件的话，可以先分别打开这两个文件进行查看，默认的配置后缀名是<code>yaml</code>，我下载的服务配置文件则是<code>yml</code>后缀，这个时候，只要删除自动生成的<code>.yaml</code>文件，并将订阅的<code>.yml</code>文件后缀名修改为<code>.yaml</code>即可</p><h2 id="第二种，直接从你的Windows-PC-上copy配置文件到Linux上就行，"><a href="#第二种，直接从你的Windows-PC-上copy配置文件到Linux上就行，" class="headerlink" title="第二种，直接从你的Windows PC 上copy配置文件到Linux上就行，"></a>第二种，直接从你的Windows PC 上copy配置文件到Linux上就行，</h2><p>因为在没有良好网络环境的情况下，很有可能无法下载对应的代理配置。但是有<code>windows</code>服务能够使用，所以<code>copy</code>配置文件到Linux上也是可行的。</p><h2 id="另，Country-mmdb的下载"><a href="#另，Country-mmdb的下载" class="headerlink" title="另，Country.mmdb的下载"></a>另，Country.mmdb的下载</h2><p>这个文件下载起来速度相当缓慢，建议采用copy的方法（直接下载还是比较耗时的）。</p><p>Linux上简单的网络配置不需要我多说了，也是动动鼠标和键盘的事情。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UNIX网络编程学习随记</title>
    <link href="/2022/01/19/2022-01-19-UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/"/>
    <url>/2022/01/19/2022-01-19-UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="UNIX网络编程学习随记"><a href="#UNIX网络编程学习随记" class="headerlink" title="UNIX网络编程学习随记"></a>UNIX网络编程学习随记</h1><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="POSIX信号处理"><a href="#POSIX信号处理" class="headerlink" title="POSIX信号处理"></a>POSIX信号处理</h3><blockquote><p>POSIX: Portable Operating System Interface of UNIX 可移植操作系统接口</p></blockquote><p>信号（signal）就是告知某个进程发生了某件事情；有时也被称为软件中断。信号通常是<strong>异步</strong>发生，也就是进程并不知道<strong>信号</strong>何时会发生。</p><p>信号有很多种，对于不同的信号的处置也是不同的：亦或简单的调用相对应的处理函数；或者忽略（<code>SIG_IGN</code>）；亦或把某个信号的处置设定为<code>SIG_DFL</code>，来进行<code>default</code>处理（例如终止进程或者就忽略掉）</p><p>信号处置的<code>POSIX</code>方法就是调用<code>sigaction</code>函数，这里采用自定义的<code>signal</code>函数来调用<code>sigaction</code>函数 </p><p>I/O复用和多线程的区别</p><p>I/O复用典型使用的场合：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20220119184539671.png" alt="典型场合"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>计网</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇到/var/lib/dpkg/status错误问题</title>
    <link href="/2022/01/19/2022-01-19-%E9%81%87%E5%88%B0_var_lib_dpkg_status%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/19/2022-01-19-%E9%81%87%E5%88%B0_var_lib_dpkg_status%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="遇到-var-lib-dpkg-status错误问题（软件包缓存错误）"><a href="#遇到-var-lib-dpkg-status错误问题（软件包缓存错误）" class="headerlink" title="遇到/var/lib/dpkg/status错误问题（软件包缓存错误）"></a>遇到/var/lib/dpkg/status错误问题（软件包缓存错误）</h1><p>在输入<code>apt-get update</code>或者类似<code>apt</code>命令时，可能会有本文中遇到的问题；</p><p>解决方法来自<strong>CSDN</strong></p><p><a href="https://blog.csdn.net/qq_33392383/article/details/86415037"> ubuntu遇见/var/lib/dpkg/status错误_重在积累-CSDN博客_/var/lib/dpkg/status</a></p><p>依次输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /var/lib/dpkg/&#123;alternatives,info,parts,triggers,updates&#125;<br><br>sudo cp /var/backups/dpkg.status.0 /var/lib/dpkg/status<br><br>sudo apt-get download dpkg<br><br>sudo dpkg -i dpkg*.deb<br><br>sudo apt-get download base-files<br><br>sudo dpkg -i base-files*.deb<br><br>sudo apt-get update<br>sudo apt-get check<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境/工具配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机如何使用clash代理</title>
    <link href="/2022/01/14/2022-01-14-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8clash%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/01/14/2022-01-14-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8clash%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机如何使用clash代理"><a href="#虚拟机如何使用clash代理" class="headerlink" title="虚拟机如何使用clash代理"></a>虚拟机如何使用clash代理</h1><p>个人Linux系统采用的是windows+虚拟机。（WSL对我来说还不够理想，Linux物理机没钱装中高配了）因为台式机配置较高，故采用了Windows + 虚拟机 + WinSCP的方案，体验还不错。但有时必须要使用科学/魔法的情况，所以采取了以下的方法；同时也避免了Linux配置<code>clash</code>的一些麻烦，只需要Windows上装有<code>clash</code>并已有可用的服务即可。本次配置采用的是<code>Debian</code>系统，<code>Ubuntu</code>的配置也应该相当类似。</p><ol><li><p>虚拟机采用桥接模式（似乎也有不采用桥接模式而成功的例子，但是我没有成功）</p></li><li><p><code>clash</code>开启<code>allow LAN</code>，并开启代理</p></li><li><p>进入<code>settings</code>进行相应的设置</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20220114002823621.png" alt="network settings"></p></li></ol><p>首先通过<code>Wired</code>旁边的设置图标，进行网络的配置服务，如上图所示：</p><p>选择<code>IPv4</code>，<code>Method</code>选择<code>Manual</code>；接下来<code>Address</code>设置为虚拟机的ip地址（输入<code>ip a</code>即可查看，注意这里不要写成了<code>127.0.0.1</code>本地机…）</p><p><code>Netmask</code>和<code>Gateway</code>具体的值通过在Windows的<em>powershell</em>输入<code>ipconfig</code>命令查看即可，并填入相应的位置。</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20220114003442996.png" alt="子网掩码和网关查看"></p><ol start="4"><li>配置完成后，选择<code>apply</code>确认应用，并选择<code>Network Proxy</code>进行代理设置</li></ol><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20220114013146747.png" alt="代理设置"></p><p>这边的端口号和地址，根据本机windows的来填，如下图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20220114013420160.png" alt="通过本机代理"></p><p>经过这番配置，虚拟机也能够正常地进行魔法上网了。</p>]]></content>
    
    
    <categories>
      
      <category>环境/工具配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于Vim的一些学习感受以及Vim for C/C++配置推荐</title>
    <link href="/2022/01/09/2022-01-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8EVim%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BB%A5%E5%8F%8AVim-for-CC++%E9%85%8D%E7%BD%AE%E6%8E%A8%E8%8D%90/"/>
    <url>/2022/01/09/2022-01-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8EVim%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BB%A5%E5%8F%8AVim-for-CC++%E9%85%8D%E7%BD%AE%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="初学者对于Vim的一些学习感受以及Vim-for-C-C-配置推荐"><a href="#初学者对于Vim的一些学习感受以及Vim-for-C-C-配置推荐" class="headerlink" title="初学者对于Vim的一些学习感受以及Vim for C/C++配置推荐"></a>初学者对于Vim的一些学习感受以及Vim for C/C++配置推荐</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经有很长时间没有写过什么总结或者知识点整理了，上次写东西还是写了一篇关于termux的使用。</p><p>期末考完了，我也彻底boom了，十二月一直在肝各种ddl，什么计网实验，公共课期末考核等等……这学期概率论和OS是我学的最不牢靠的两门课，计网倒是勉强还凑合。再加上我校按排名定GPA（<del>什么nc规定啊</del>），这学期前本还想着好好学习，想办法把成绩拉上来一点好出去读水硕混个学历，结果大概率这学期是没了。</p><h3 id="话说回来，我为什么要学习并配置Vim？"><a href="#话说回来，我为什么要学习并配置Vim？" class="headerlink" title="话说回来，我为什么要学习并配置Vim？"></a>话说回来，我为什么要学习并配置Vim？</h3><p>因为我想在Linux环境下写代码，Windows对于我更适合日常娱乐。Linux相较于Windows，配置环境也更加的方便。（但烦人的地方还是烦）</p><p>有兄弟可能会说：Linux环境下用VSCode不香吗？用IDE(如CLion, QT Creator，轻量的有Code::Blocks, CodeLite, Geany……)不香吗？</p><p>我觉得，确实很香！好用就完事了啊！！！！</p><p><em><strong>但如果我没有图形化界面怎么办？</strong></em></p><p>这个学期我租用了某云的轻量应用服务器；只能用Terminal远程SSH写程序的我，自然逃不掉Vim的使用了。</p><p>除了这个所谓的“<strong>刚需</strong>”，个人学习Vim操作并配置Vim，纯粹是自己喜欢折腾，想尝试新东西（对我个人来说），并且这学期我还“有时间”。（问就是这学期代码量少得可怜，所以有“时间”瞎搞，<del>另外不拿键盘敲点什么，人就感觉不舒服</del>）</p><p><strong>另外，</strong></p><p><strong>这篇文章不敢说是什么入门教程，连“学习心得”都不一定算得上，但我想分享一些我自己配置折腾Vim的感受，请各路大佬或者IDE党勿喷！绝无显摆或是踩一捧一的意思）</strong>我也没有上过y总的Linux课，文章内容若存在重复的，请见谅！</p><h3 id="参考的一些资料"><a href="#参考的一些资料" class="headerlink" title="参考的一些资料"></a>参考的一些资料</h3><p>这里也得感谢某乎，精准推送了Vim相关内容，我就进了Vim的坑。</p><p>另外，某乎以及广大的互联网世界（包括AcWing在内）有不少大佬出没，如@韦易笑，会分享一些Vim相关配置还有好用的插件介绍。有兴趣的同学可以自行搜索~</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文是面向刚入坑Vim的新人的（其实我也是新人），希望能对同学们有所帮助。接下来从<strong>如何上手</strong>，一些<strong>键位技巧（辅助记忆）</strong>，<strong>Vim个性化配置</strong>等分别来介绍。在写这篇文章时，本人使用的环境是：Debian 11, Vim 8.2    （Ubuntu20.04，Vim8.1应该也是适用的）</p><h3 id="如何上手"><a href="#如何上手" class="headerlink" title="如何上手"></a>如何上手</h3><p>在Linux环境下安装Vim是很简单的，只需要命令行输入<code>sudo apt install vim</code>即可（如果是普通用户）。</p><p>终端中输入<code>vim --version</code>，即可查看Vim版本，以及一些功能的支持。例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220109023231.png" alt="image-20220109023231766"></p><p>最简单粗暴的一个方法，上网搜索Vim键位去多打多练，形成所谓的肌肉记忆。</p><p>另外，直接在终端里输入<code>vimtutor</code>，跟着官方教程来练习也是个不错的选择。但前提是你英语过得去，不过网上也有vimtutor中文翻译可供参考。</p><p>另外我还看过一个不错的vim教程<em>《简明Vim练级攻略》</em>，大家可以自行搜索。</p><p>但熟练掌握Vim键位还是需要不断地练习，这个过程可能会比较痛苦。（这也许就是Vim劝退大部分人的原因吧）但掌握了Vim键位，敲击键盘的感觉真的让人很舒服。</p><h3 id="键位记忆技巧"><a href="#键位记忆技巧" class="headerlink" title="键位记忆技巧"></a>键位记忆技巧</h3><p>Vim作为一种编辑器，其特点就是命令及输入内容的分离。Vim有多个模式，最常用的是Insert插入模式以及Normal常规模式。</p><p>当然还有其他的一些模式，比如Visual可视模式，也是很常用的。</p><p>所以可以根据首字母来进入不同的模式。刚进入Vim，默认是在Normal常规模式下。比如输入<code>i</code>进入Insert 模式， 输入<code>v</code>进入Visual可视化模式。敲<code>&lt;ESC&gt;</code>键则是离开当前模式，回到Normal模式。在Normal模式下输入<code>:</code>则是进入了命令模式，比如stackoverflow的高赞问题 <em>如何退出Vim编辑器？</em>输入<code>:q</code>即可。（q即quit）</p><p><strong>这里我想先特别强调出一个键位</strong> <code>&lt;ESC&gt;</code>，这个键位可以说是除了英文字母以外，使用频率很高的一个键。但！这个键却在大部分键盘上，离我们的手相当的远，未免有些反人类了。这里提供一些解决方法：</p><ol><li>更改键盘映射，把CAPS LOCK映射成CTRL</li><li>用<code>ctrl</code> + <code>[</code> 代替<code>Esc</code>键，在vim中，ctrl + [ 是等效于Esc键的。</li><li>对于输入<code>ctrl</code>键，对于一大部分人来说，仍然是不太顺利的。这个时候可以选择如同(1)的方法，互换CAPS LOCK和Ctrl的映射。此外，我根据网上的讨论，发现有前辈选择用小拇指根，或者手掌的外边沿侧（大约是靠近小指以下的区域）去敲击<code>Ctrl</code>。本以为这样误触会比较多，但实际体验下来，几乎是没有误触，只是感觉可能会略有些奇怪hh</li><li>自定义配置，映射某些键作为<code>ESC</code>，这个待会儿具体在<strong>自定义配置</strong>部分讨论。</li></ol><p>我本人使用的是<code>ctrl</code>+<code>[</code>来代替escape键，体验也很顺畅，没有什么问题（除了有的时候力气太小导致ctrl没触发到）。</p><p><em>顺便说句，为什么有些键位那么的反人类？因为，那个时候的键盘布局和现在还是有挺大区别的。默认的键位映射放到现在，也是属于“历史遗留问题”了</em></p><p><strong>说回正题！</strong>vim的键位是比较复杂的，功能也很多，例如<code>y</code>,<code>gg</code>,<code>G</code>,<code>i</code>,<code>A</code>,<code>d</code>,<code>o</code>,<code>0</code>等等。</p><p><code>y</code>的作用是复制，输入<code>yy</code>则会复制当前光标所在行。<code>y</code>其实代表的是 yank，有复制的含义。</p><p>再比如，<code>dd</code>是删除当前行，<code>dw</code>则是删除当前光标到下一个空格的内容。<code>daw</code>则是可以删除当前光标所在单词（delete a word）。还有<code>di(</code> <code>di[</code>,这是删除相应括号内的内容（delete in ()/ delete in []）。</p><p>还有<code>A</code>键，光标会移动到当前行末尾，并进入Insert模式。A代表Append…..</p><p>通过英文单词来辅助记忆一些键位，并加以一定量的训练。正常流畅的使用是指日可待的。</p><h3 id="Vim个性化配置"><a href="#Vim个性化配置" class="headerlink" title="Vim个性化配置"></a>Vim个性化配置</h3><p>Vim有一批“信徒”“狂热爱好者”的原因就是：Vim可以自由定制，自己想怎么玩怎么玩。几乎想映射什么键到什么键都可以实现！</p><p>Vim的配置文件是<code>.vimrc</code>，可以在用户目录<code>home/username/</code> 也就是<code>~</code>目录下进行配置。</p><p>终端中输入<code>vim ~/.vimrc</code>，即可创建Vim的配置文件。</p><blockquote><p> 另外：</p><p>还有人习惯在用户目录下创建<code>.vim</code>文件夹，然后在<code>.vim</code>文件夹中新建一个Vim配置文件，即<code>vim ~/.vim/.vimrc</code>（这样做可以方便使用git，对.vim文件夹进行同步，从而达到不同机器上的配置统一）。</p><p>我个人的习惯也是用户目录下创建一个.vimrc文件，即<code>vim ~/.vimrc</code>，随后在~/.vim/.vimrc中配置真正想要</p><p>至于<code>~/.vimrc</code>的内容，如下所示，仅一行即可：</p></blockquote><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220109041759.png" alt="image-20220109041759482"></p><blockquote><p>如果采用和我类似方法的同学这里不要有差错或遗漏，否则可能会报错。</p></blockquote><h4 id="一些基本的"><a href="#一些基本的" class="headerlink" title="一些基本的.."></a>一些基本的..</h4><p>下面是个人Vim配置的一小部分</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">showtabline</span>=2<span class="hljs-string">&quot;tabline强制显示</span><br><span class="hljs-string">set nu&quot;</span>在一旁显示行号<br><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">tabstop</span>=4<br><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">shiftwidth</span>=4“这行和上一行是负责设置缩进宽度<br><span class="hljs-builtin-name">set</span> autoindent<span class="hljs-string">&quot;设置自动缩进</span><br><span class="hljs-string">set cursorline&quot;</span>使得当前光标所在行出现一条下划线，以标明所在行<br><span class="hljs-builtin-name">set</span> showcmd<span class="hljs-string">&quot;可以显示正输入的命令</span><br><span class="hljs-string">set ruler&quot;</span>显示光标现在的位置（坐标）<br><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">syntax</span>=on<br></code></pre></td></tr></table></figure><p>相信各位也发现了，<code>vimscript</code>的语法并不难，自己也可以通过模仿别人的样例，来修修改改，配置自己的<code>.vimrc</code>。</p><h4 id="leader键是干嘛用的？"><a href="#leader键是干嘛用的？" class="headerlink" title="leader键是干嘛用的？"></a>leader键是干嘛用的？</h4><p>接下来是关于<code>leader</code>键的设置，<code>leader</code>键对于vim个性化操作是非常重要的。</p><p><code>let mapleader=&#39;,&#39;</code>    我个人把<code>leader</code>设为了逗号<code>,</code>        而这里完全可以根据个人喜好来设置。</p><p>如果有同学和我一样，<strong>对Vim配置文件需要做大量修改的</strong>。可以选择定制键位如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;quickly edit the .vimrc</span><br><span class="hljs-string">nnoremap &lt;silent&gt; &lt;leader&gt;ee :e ~/.vim/.vimrc&lt;CR&gt;&quot;</span>&lt;CR&gt;是回车键<br></code></pre></td></tr></table></figure><p>这样，在Normal模式下，输入leader键+连续两个<code>e</code>，就能快速打开<code>.vimrc</code>来进行查看并编辑。</p><p><strong>注：</strong>这里的<code>nnoremap</code> 实际含义是(in)normal mode, no re- map，意指在normal模式下，不进行重映射（重映射也就是键位可以映射再映射的意思），一次映射完结束。</p><p>同理，<code>inoremap</code> 实际含义是(in)insert mode, no re- map</p><h4 id="Vim难道也有外观党？"><a href="#Vim难道也有外观党？" class="headerlink" title="Vim难道也有外观党？"></a>Vim难道也有外观党？</h4><p>大部分同学通常会发现，一些大佬的Vim配置得“花里胡哨”，功能多还好看！</p><p>下面是一些外观方面的设置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">if exists(&#x27;$TMUX&#x27;)<br>set term=screen<span class="hljs-number">-256</span>color<br>endif<br><span class="hljs-comment">//兼容TMUX的使用</span><br><br>colorscheme koehler <span class="hljs-string">&quot;设置Vim主题颜色为koehler</span><br><span class="hljs-string">&quot;</span>colorscheme solarized<br><span class="hljs-string">&quot;colorscheme desert </span><br><span class="hljs-string"></span><br><span class="hljs-string">if has (&#x27;gui_running&#x27;)</span><br><span class="hljs-string">set background=light</span><br><span class="hljs-string">else</span><br><span class="hljs-string">set background=dark</span><br><span class="hljs-string">endif</span><br><span class="hljs-string"></span><br><span class="hljs-string">set t_Co = 256</span><br><span class="hljs-string"></span><br><span class="hljs-string">if has (&quot;</span>termguicolors<span class="hljs-string">&quot;)</span><br><span class="hljs-string">set termguicolors</span><br><span class="hljs-string">endif</span><br></code></pre></td></tr></table></figure><p>你可以使用Vim时，进入Normal模式，然后输入<code>:colorscheme </code>+ 你喜欢的颜色，</p><p>例如<code>:colorscheme solarized</code>，就可以查看当前颜色主题（solarized）下的效果。</p><p>然后在<code>.vimrc</code>里，固定下你想要的颜色即可（当然也可以设置随机配色）</p><p><strong>虽然，更加重要的是，终端的颜色…！！！</strong></p><h4 id="C-C-快速编译-运行一段代码"><a href="#C-C-快速编译-运行一段代码" class="headerlink" title="C/C++快速编译+运行一段代码"></a>C/C++快速编译+运行一段代码</h4><p>如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;---------------QUICK COMPILE---------</span><br><span class="hljs-string">nnoremap r :call CompileRunGcc()&lt;CR&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">function! CompileRunGcc()</span><br><span class="hljs-string">execute &quot;</span>w<span class="hljs-string">&quot;</span><br><span class="hljs-string">if &amp;filetype == &#x27;c&#x27;</span><br><span class="hljs-string">if !isdirectory(&#x27;build&#x27;)</span><br><span class="hljs-string">execute &quot;</span>!mkdir build<span class="hljs-string">&quot;</span><br><span class="hljs-string">endif</span><br><span class="hljs-string">execute &quot;</span>!gcc % -o build/%&lt; -g<span class="hljs-string">&quot;</span><br><span class="hljs-string">execute &quot;</span>!time ./build/%&lt;<span class="hljs-string">&quot;</span><br><span class="hljs-string">endif</span><br><span class="hljs-string"></span><br><span class="hljs-string">if &amp;filetype == &quot;</span>cpp<span class="hljs-string">&quot; </span><br><span class="hljs-string">if !isdirectory(&#x27;build&#x27;)</span><br><span class="hljs-string">execute &quot;</span>!mkdir build<span class="hljs-string">&quot;</span><br><span class="hljs-string">endif</span><br><span class="hljs-string">execute &quot;</span>!g++ % -o build/%&lt; -g<span class="hljs-string">&quot;</span><br><span class="hljs-string">execute &quot;</span>!time ./build/%&lt;<span class="hljs-string">&quot;</span><br><span class="hljs-string">endif</span><br><span class="hljs-string">endfunction</span><br></code></pre></td></tr></table></figure><p>比如写了一个hello_world.cpp，进入normal模式，然后按下<code>r</code>，就能直接在当前目录下编译，并把可执行文件放入了当前目录的<code>build</code>文件夹中（不污染代码文件），并执行可执行文件。</p><h3 id="Vim插件"><a href="#Vim插件" class="headerlink" title="Vim插件"></a>Vim插件</h3><p>网上有很多，包括AcWing上也有不少大佬，分享了自己的Vim配置，包括括号补全这种功能也是手动实现。我只能说一句respect！</p><p>但正是丰富的Vim插件，让我彻底爱上了这款编辑器。喜欢DIY电脑的我，也特别享受给自己编辑器装插件，实现功能的过程。</p><p>但在此之前，我要先介绍一款插件管理工具：<code>vim-plug</code>，这将大大方便Vim维护插件的易用性。</p><h4 id="插件管理工具：vim-plug"><a href="#插件管理工具：vim-plug" class="headerlink" title="插件管理工具：vim-plug"></a>插件管理工具：vim-plug</h4><p>详细的如何安装，如何使用可以参考Github上该项目的README。</p><p>但可能安装该工具（包括后续安装插件）会遇到一些网络问题（原因懂得都懂），可以采取科学上网的方式解决；或是换镜像源来方便使用。换源的方式可以自行查询；如果有可能，我也可能会写一篇有关Linux环境遇到的坑。</p><h4 id="有关写代码、阅读代码的插件"><a href="#有关写代码、阅读代码的插件" class="headerlink" title="有关写代码、阅读代码的插件"></a>有关写代码、阅读代码的插件</h4><p>声明：这些插件几乎全部可以在Github上找到，一些如何安装、使用的基本问题以官方文档为准。在这里还推荐一个网站叫VimAwesome，是对刚接触插件的新人的一个”宝藏网站“。</p><ol><li><p><code>vim-cpp-enhanced-highlight</code></p><p>提供C/C++的高亮显示</p></li><li><p><code>auto-pairs</code></p><p>这个顾名思义，就是提供了括号补全功能</p></li><li><p><code>ale</code></p><p>这个插件就比较有意思了，支持异步检错，同时它还可以和<code>cppcheck</code>等工具产生类似“联动”的效果，可能的内存泄漏都能检测出来。<del>虽然我cppcheck就被配置成功过</del>    但是<code>ale</code>也是一个非常庞大的插件，功能也不仅仅限于检错这一种，所以ale也需要自己的配置；也可参考网上大佬的配置。</p></li><li><p><code>YouCompleteMe</code>,简称YCM</p><p>一款很强的智能补全插件（支持多语言），但要一番功夫进行配置。本人并没有采用YCM.</p></li><li><p><code>coc.nvim</code></p><p>这款插件，我最初知道是因为它能比较方便地进行补全（同样支持多语言）。但实际上，<code>coc</code>的野心绝不至于此，他的目标似乎是把Vim打造成另一个VSCode（？？？）这里就不做过多的阐述，感兴趣的同学可以自行查询资料。</p><p>这是我个人使用<code>coc.nvim</code>的效果图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220109213343.png" alt="image-20220109213343483"></p></li><li><p>配置<code>ctags</code>和<code>gutentags</code></p><p>tags其实是阅读项目所需要的。这里由于篇幅限制，就不再赘述。</p></li><li><p><code>nerdtree</code></p><p>这款插件，提供了文件树的效果。</p><p>但我现在已经把他替换成了<code>coc-explorer</code>，而这是<code>coc.nvim</code>的扩展插件（属于是插件的插件，套娃了）</p></li><li><p><code>LeaderF</code>（需要python支持）</p><p>这是一款支持模糊查找的插件，也是国人开发的一款Vim插件，功能很多，也很好用，我直接将之替代了下面的Tagbar</p></li><li><p><code>tagbar</code></p><p>配置好tags之后，tagbar就能在一旁显示出效果。</p><p>这是<code>tagbar</code>的效果图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220109205930.png" alt="image-20220109205929880"></p><p><em>当然，这是github上一个sudoku项目的代码，不是我自己的代码….</em></p></li></ol><p>​        这是之前所提到的我用来替代<code>tagbar</code>的东西，这也只是<code>Leaderf</code>的其中一个功能而已（当然也需要tags已经配置好）…:</p><p>​        <img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220109210159.png" alt="image-20220109210159269"></p><h4 id="外观插件"><a href="#外观插件" class="headerlink" title="外观插件"></a>外观插件</h4><ol><li><code>vim-airline</code></li><li><code>vim-airline-themes</code></li><li><code>vim-airline-clock</code></li></ol><p>这三个插件以<code>airline</code>为基础，给较为单调的Vim界面增添了几分活力（其实就是上图中，底部状态栏一样的东西）。<code>airline</code>也有不少可以设置的地方，留下了给外观党折腾的空间。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>未提到的插件（如<code>vim-spector</code>，据说是一款debug神器），我自己可能未上手体验过，或是遗忘了。在这里就不做贸然的推荐，了解的大佬也可以补充~</p><p>另外有些插件需要一定环境的支持，比如<code>Leaderf</code>需要Python支持，Debian软件源中的Vim似乎并不支持python，还需要下载源码进行手动编译安装，过程较复杂，且容易出错（但Ubuntu就不用）。    而很好用的<code>coc.nvim</code>功能多，也需要nodejs的支持。如遇到插件的问题，还是要多参考官方docs/wiki。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写完这篇文章，我开始思考：<em>我配置Vim的意义在哪里？</em></p><p>我喜欢在自己感兴趣的东西上投入时间，我也没有因为配置Vim，而荒废了学业（虽然这学期我的OS理论课和实践大概率糊了）。我也不是一个喜欢打游戏的人，Steam库的游戏吃灰一个学期了就没打过，在课余时间折腾Linux也好，Vim也好，搞内网穿透也好，也算是我娱乐的一种方式吧。另外，仍有一批前辈在给Vim 或 Neovim 贡献自己的力量，也非常感谢这些前辈的努力！</p><p>期末前，恰应计网实践课要求，拿自己配置的Vim写了个简单的socket的demo程序，体验还ok。</p><p>这也是我第一次写那么长的总结。<strong>若有需要提意见的，都可以在评论区直接指出，我将不胜感激。</strong>（如果这东西真有人看的话）</p><p>这个寒假不出意外，我会多刷点算法题，数据结构这块我一直学的不扎实；另外学学网络编程这方面的东西；还有太多要补的： Makefile, gdb,  CMake, etc. 下学期要学数据库了，寒假里试着跟个CMU15-445学学其实也不错。虽然现在列了很多要做的，但哪怕最后只有一件事情做好了，也还不错了233</p>]]></content>
    
    
    <categories>
      
      <category>环境/工具配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓平板、甚至手机也能写代码？Termux使用体会分享</title>
    <link href="/2021/11/16/%E5%AE%89%E5%8D%93%E5%B9%B3%E6%9D%BF%E3%80%81%E7%94%9A%E8%87%B3%E6%89%8B%E6%9C%BA%E4%B9%9F%E8%83%BD%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9FTermux%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A%E5%88%86%E4%BA%AB/"/>
    <url>/2021/11/16/%E5%AE%89%E5%8D%93%E5%B9%B3%E6%9D%BF%E3%80%81%E7%94%9A%E8%87%B3%E6%89%8B%E6%9C%BA%E4%B9%9F%E8%83%BD%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9FTermux%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓平板、甚至手机也能写代码？Termux使用体会分享"><a href="#安卓平板、甚至手机也能写代码？Termux使用体会分享" class="headerlink" title="安卓平板、甚至手机也能写代码？Termux使用体会分享"></a>安卓平板、甚至手机也能写代码？Termux使用体会分享</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>自己几个月前在某鱼收的<strong>surface go</strong>有点废，虽然跑跑<em>VS Code</em>没啥问题，但是运行一些国产臃肿软件，就不定时卡顿……本来想去买 go3 的，但可惜囊中羞涩实在没钱；且见识有限，目光限定在大一入学前的就买来暂替笔记本的matepad。在这个过程中突然发现了<strong>Termux</strong>终端这款软件，甚至还能运行<code>python</code>，安装<code>clang</code>甚至还能跑<code>C/C++</code>（貌似<code>gcc</code>和<code>g++</code>没法直接装，但是可以通过曲线救国…)</p><p><del>为什么AcWing的大佬巨巨们都在搞OI，ACM，而我已经大二了还搁着瞎折腾….？？</del></p><p>最搞笑的事情是，这小东西居然还能装Linux环境？直接在上面装Ubuntu等发行版都没啥问题（虽然是arm版）</p><p>从上周末开始折腾了两天，最后决定弃坑（bushi，过两天要OS考试了，即将爬了。</p><p><strong>文末也提到了其他的一些方案，如AidLearning， Termux + AnLinux , tmoe脚本安装等等</strong></p><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p><strong>前置要求：</strong></p><ol><li><p>软件：coolapk，或者D-droid， 有能力的也可以去Google-play上下载Termux。</p></li><li><p>硬件：运行着安卓系统的手机，正常能跑，不算太老就行。。。。如果可以的话弄个蓝牙键盘输入，按屏幕手残党落泪……</p></li><li><p>其他：有时间= =玩，会一点点Linux相关知识：vi编辑，ssh远程连接就可。</p></li></ol><p>安装好之后，建议先换源。输入以下指令：</p><p><code>vi $PREFIX/etc/apt/sources.list</code></p><p>如果vi不会用的话，记住一下两个点就行：</p><ol><li><p>两个模式切换。记住<code>ESC</code>和<code>i</code>键：前者是进入Normal模式进行保存，退出等命令操作；按一下i键，就进入编辑模式，然后正常输入英文就行。</p></li><li><p>输入完之后，再按一下ESC键，进入了Normal模式之后，再输入<code>:wq</code>，按下回车就成功退出了。</p><p><em>有个笑话：Q:如何得到一串随机字符串？ A: 让一个新人退出vim即可</em></p></li></ol><p>换源的话，具体可以换清华源，或是科大源。这两者都能成功安装Linux环境，但似乎后者我不太会用..由于时间问题，我个人觉得前者的help docs做的更友善一点，后者没来得及多探究。</p><hr><p>换源后，可以安装很多软件了，这里我习惯先安装<code>openssh</code>，输入<code>pkg install openssh</code>即可，注意可能会让你输入<code>y/n</code>，输入y，按回车即可。</p><p>然后输入<code>passwd</code>，自己设置ssh远程连接需要的密码。之后就可以在笔记本等平台上远程操作了，平板还行，旧手机的小屏是真的难受……</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211116131327.png" alt="安装ssh，这里因为我已经安装好了，所以显示的与未安装状态是不一样的"></p><p><strong>这里我想说明这款软件的一个缺陷：需要保留后台程序，否则切出去之后，被“杀后台”就不妙了。具体保留后台进程相信大家都会……</strong></p><p>设置完密码后，输入<code>sshd</code>开启ssh服务，之后可以在其他平台上进行远程连接来控制了。<code>sshd</code>这条命令，只要你把Termux进程<code>exit</code>出去，就要重新输入，从而开启ssh服务（当然也可以写自动化脚本？），但我还是选择保留Termux后台，反正也是自己不太用的旧手机。</p><p>可以输入<code>ifconfig</code>来查看手机端的地址，如下图所示：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211116132316.png"></p><p>注意一个点：这里的ssh应该是以8022端口进行连接；具体连接成功的情形如下：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211116132748.png" alt="我这里是用Windows Terminal连接的，局域网ip为192.168.1.100"></p><p>第一个<code>Connection refused</code>就是没有开启sshd服务导致的，如果也出现连不上的情况，先考虑地址、端口问题，再考虑服务<strong>是否开启</strong>！</p><p><del>后来的输入密码输错就是手残</del></p><hr><p><strong>安装Linux过程:</strong></p><p>这里换的是清华源（也可以选择保留原来的源设置而不是覆盖）。具体参考官方帮助：</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/termux/">termux | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>还原后输入<code>apt update</code>，如果出现<code>apt</code>命令无法识别，那可能还需要<code>pkg install apt</code>.</p><p>随后安装<code>proot</code></p><p><code>pkg install proot-distro</code></p><p>之后可以输入<code>proot-distro list</code>，查看可以安装的Linux系统</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211116135438.png"></p><p>如果想要安装Ubuntu,就输入<code>proot-distro install ubuntu</code>即可。</p><p>之后就是Linux相关的设置了，想咋玩咋玩儿。</p><hr><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>实际上折腾了两天，我研究出来Termux合适的用处是：</p><ol><li><p>部分程度上替代树莓派，虽然老手机芯片还是不错的，但是树莓派的I/O扩展强得多。尤其是旧手机，有些还是MicroUSB接口，那真是谢天谢地了。搭建出的Linux环境临时测试写几个短代码还是没啥问题的。运行一些有趣的功能233，树莓派能做的，他貌似大多数也可以玩儿。（但I/O扩展太差了，本来还想外接硬盘当轻nas，很明显想多了……）</p></li><li><p>Termux说到底，终端才是他最基础的功能，将之ssh连接至服务器（包括云服务器），或者任意一台电脑（有公网IP或者能采取内网穿透也行）终端写代码。这个法子的局限性在于，如果是pc/mac端，VSCode 直接配合<code>remote-SSH</code>插件就可以非常顺滑的写代码了（前提是网好……）；<strong>但是</strong>终端情况下，似乎只有<code>Vim</code> or <code>Emacs-cli</code>可以使用….</p><p>（虽然这两天我配置<code>Vim</code>配的很起劲，属于发病作死了hhh，不过<code>Vim</code>现在也有强大插件支持，写C/C++确实还可以，其他语言没试过）这一点隔壁iPad/iPhone 也有iSSH可以使用。安卓端有Termux, juiceSSH，ConnectBot等软件支持。</p></li><li><p>在Linux环境里部署code-server，随后保留Termux，切换应用到浏览器里敲代码（但我尚未尝试，并且这样的话，要求在一个局域网下，否则需要公网IP或进行内网穿透）（另：微软最近推出了vscode.dev，可以直接在浏览器写代码，但插件生态支持是个大问题）</p></li><li><p>VNC Viewer 远程Linux桌面，其实现出的效果类似于微软RDP，但配置起来也比较折腾；虽然有之前提到的别人写好的<strong>脚本安装</strong>，那一套下来还是很舒服的，网上也有成品展示。（米板5跑cs1.6，运行office各种骚操作）</p></li><li><p>还有<strong>AidLearning</strong>也是类似的一个开源项目，也可以达到不错的效果，虽然对老手机兼容性就不算特别好了，近三年的大概还行。</p></li></ol><p><em>另外有个软件推荐一波，<strong>zerotier</strong>，真心不错，几个机器可以通过它“虚拟”在一个局域网内</em></p><p>可能还有些别的玩法，也待各位大佬补充……（话说这会有人看吗？）</p><p>如果可能的话，我之后考虑写一篇初学者配置vim的操作，或者推荐一些vim插件也行……</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点梳理（课内）</title>
    <link href="/2021/10/21/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/"/>
    <url>/2021/10/21/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h3><p>Computer network: a collection of autonomous computers interconnected by a single technology</p><ol><li><p>autonomous: be able to compute independently</p></li><li><p>interconnected: be able to exchange information</p></li></ol><p>Computer networks: collections of autonomous computers </p><p>​    例如：the Internet</p><p>Computer networks VS. Distributed systems:</p><ul><li>In distributed systems, a model on top of the network is used to present the independent computers to users as a single coherent system, e.g., the Web.</li><li>Who makes the decision?—- Users VS. OS</li></ul><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ul><li><p>按照传输技术</p><p>广播网络和点到点网络（单播）    Broadcast links and Point-to-point links</p></li><li><p>按照距离尺度</p><p>个域网、局域网、城域网、广域网和互联网</p><p>PAN        LAN        MAN        WAN</p></li></ul><h3 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h3><blockquote><p>本节需要掌握的内容包括：</p><p>1） 一组概念：对等体、协议、服务、接口、计算机网络体系结构、协议数据单元PDU、SDU；</p><p>2） 计算机网络协议分层的好处和缺点，通过协议分层实现数据封装及解封的过程；</p><p>3） 面向连接服务和面向无连接服务的特点及实现过程；</p><p>4） 面向连接与面向无连接VS.可靠与不可靠</p></blockquote><ol><li><p>服务：层间交换信息时必须遵守的规则。</p></li><li><p>接口：定义了下层向上层提供的原语操作和服务。</p></li><li><p>第N层协议：</p><ul><li><p>不知道上、下层的内部结构</p></li><li><p>独立完成某种功能</p></li><li><p>为上层提供服务</p></li><li><p>使用下层提供的服务</p></li></ul></li></ol><p><em>说人话就是上一层通过接口收到下一层送上门来的东西（大雾）</em></p><hr><p>有个具体的生活中的例子作为类比：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914000941.png" alt="哲学家-翻译-秘书层级"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914001218.png" alt="协议分层"></p><ol><li><p>同一层级的通信，即水平通信（也是peer-to-peer的），属于虚拟通信</p></li><li><p>相邻层的通信是实际通信</p></li></ol><p><strong>一些概念：</strong></p><ul><li><p>服务访问点SAP（Service Access Point）</p><p>任何层间服务是在接口的SAP上进行的，每个SAP有唯一的识别地址</p><p>每个层间接口可以有多个SAP </p></li><li><p>接口数据单元IDU（Interface Data Unit）</p><p>IDU是通过SAP进行传送的层间信息单元</p><p>IDU由上层的服务数据单元SDU（Service Data Unit）和接口控制信息ICI（Interface Control Information）组成</p></li><li><p>协议数据单元PDU（Protocol Data Unit）</p><p>第N层实体通过网络传送给它的对等实体的信息单元</p><p>PDU由上层的服务数据单元SDU或其分段和协议控制信息PCI（Protocol Control Information）组成</p></li><li><p>服务数据单元SDU（Service Data Unit）</p><p>跨过网络传给对等实体并交给上层的信息</p></li></ul><blockquote><p>SDU（service Data Unit）:服务数据单元，又叫业务数据单元，是指定层的用户服务的数据集，传送到接收方的时候同一协议层时数据没有发生变化，即业务部分，然后发给下层之后，下层将其封装在PDU中发送出去。服务数据单元是从高层协议来的信息单元传送到低层协议。第N层服务数据单元SDU，和上一层的协议数据单元（PDU）是一一对应的。根据协议数据单元的数据的不同，送到接收端的指定层。</p><p>PDU（Protocol data unit）: 协议数据单元：<strong>计算机网络各层对等实体间交换的单位信息</strong>，例如TCP层的PDU就是segment（分节）、应用层间交换的PDU则是application data（应用数据）</p><p>转自： <a href="http://blog.csdn.net/wind19/article/details/4669637">http://blog.csdn.net/wind19/article/details/4669637</a></p></blockquote><p>存在公式：</p><p>PDU(N) = SDU(N - 1)</p><p>SDU(N) = PDU(N + 1)</p><p>对于某一层来说，收到的是SDU;</p><p>处理完出去的是PDU，那么对于下一层来说，这块PDU就是下一层的SDU</p><blockquote><p>N层用户与N层协议之间传递的数据称为服务数据单元(SDU)<br>N层协议实体之间传递的数据称为协议数据单元（PDU），通过数据发送/接收管理把用户提交的SDU以PDU的形式，通过下层通道发送到对端协议实体。在接收端再将PDU还原成SDU送给收端用户。<br>PDU的封装/解封装：在发送方，将用户递交的SDU加上协议控制信息PCI，封装成PDU；在接收方，讲接收到的PDU解封装，去掉PCI，还原成SDU送交接收方用户。<br>SDU分段/装配 ：如果下层通道的带宽不能满足传递SDU的需要，就需要将一个SDU分成多段，分别封装成PDU发送出去（分段）；在接收方再将这些PDU解封装后重新装配成SDU。<br>SDU拼接/分离：拼接是指在发送方(n)层协议实体把多个长度较短的(n)SDU封装成一个(n)PDU来发送，在接收放再将接收到的(n)PDU解封装，将多个(n)SDU分离出来。采用拼接功能的目的是提高通道的利用率。<br>PDU分割/组合：PDU分割是指在发送端(n)层协议实体把一个(n)PDU分割成多个(n-1)SDU，并行地从多个(n-1)通道发送出去；接收端再将收到的多个(n- 1)SDU组合成一个(n)PDU。由于这是一个N层功能，所以组合操作在N层中进行，即N层先得到多个分割开的(n)PDU，然后把它们组合成一个(n)PDU。</p><p>转自：<a href="https://blog.csdn.net/zhangxiao93/article/details/51253933">(52条消息) 网络通信PDU和SDU的区别_上善若水-CSDN博客_pdu sdu</a></p></blockquote><p>简而言之，一个SDU可能要封装在多个PDU中传输，    N层的PDU = N层的PCI + N层的SDU</p><hr><p><strong>网络协议分层的优缺点：</strong></p><ul><li>缺点：层次多，效率低</li><li>优点：层次间相互独立，无需知道相邻层次的具体完成细节；模块化维护方便，只需要接口、提供的service不变就可以；也容易进行复用。</li></ul><blockquote><p>Stanford CS144:</p><ol><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Separation of concerns</li><li>Continuous improvement</li><li>Peer-to-peer communications （eg. the Internet 使用互联网不需要考虑如何实现通信）</li></ol></blockquote><p><strong>面向连接和面向无连接</strong> &amp; <strong>可靠与不可靠</strong></p><p>见中文书本P27-29</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151244.png" style="zoom:80%;" /><hr><h3 id="服务与协议的关系"><a href="#服务与协议的关系" class="headerlink" title="服务与协议的关系"></a>服务与协议的关系</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151621.png" alt="书本P36 服务 vs. 协议" style="zoom:80%;" /><hr><h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p>博客园上有老哥做了一个OSI七层 和 TCP/IP五层模型的小总结，写的还不错</p><p>链接：<a href="https://www.cnblogs.com/qishui/p/5428938.html">OSI七层模型与TCP/IP五层模型 - SevenFormer - 博客园 (cnblogs.com)</a></p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151739.png" style="zoom:60%;" /><p>——<em>上图需要注意通信子网协议边界，路由涉及到第三层，交换机涉及到第二层</em>——–</p><ol><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p><p>用户需要的各种各样的协议，例如HTTP（超文本传输协议）</p></li></ol><h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4><ol><li><p>链路层</p><ul><li>该层描述了链路必须完成什么功能，才能满足无连接的互联网络层的需求，比如串行线和经典以太网链路</li><li>这不是真正意义上的一个层，而是主机和传输线路的一个接口</li></ul></li><li><p>互联网层</p><ul><li>大致对应OSI网络层，该层任务是允许主机将数据包注入到任何网络，让这些数据包独立到达接收方（也许接收方在不同的网络上）（数据包到达顺序和发送顺序也可能不一）</li><li>这里的internet是指一般意义上的互联网络，非现在所说的<em>互联网</em>。</li><li>该层定义了官方数据包格式和协议，即IP协议，还有辅助协议因特网控制报文协议ICMP，该层还需要考虑拥塞控制问题（Congestion Control）</li></ul></li><li><p>传输层</p><ul><li>允许源主机和目标主机的对等实体进行对话，如同OSI传输层</li><li>定义有两个端到端的传输协议，分别是传输控制协议TCP 和 用户数据报协议 UDP</li></ul><p><strong>TCP:</strong></p><p>可靠、面向连接；还负责流量控制（接收方和发送方）；将输入的字节流分割成离散的报文，再传递给互联网层；在目标机器，接收TCP进程会把收到的报文重新装配到输出流中。（生活实际：下载文件）</p><p><strong>UDP:</strong></p><p>不可靠、无连接协议；广泛应用于一次性的客户机-服务器类型的“请求-应答”查询应用，以及<strong>及时交付</strong>更为重要的应用（比如传输语音或视频）</p></li><li><p>应用层</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154219.png" style="zoom:60%;" /></li></ol><h4 id="两种模型的共同点和不同点"><a href="#两种模型的共同点和不同点" class="headerlink" title="两种模型的共同点和不同点"></a>两种模型的共同点和不同点</h4><p><strong>共同点：</strong></p><ul><li>以协议栈概念为基础；协议栈中协议彼此独立；层功能大致相似</li></ul><p><strong>不同点：</strong></p><ul><li>OSI模型核心：服务；接口；协议。</li></ul><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154914.png" alt="书本P38" style="zoom:60%;" /><ul><li><p>TCP/IP模型最初并没有明确区分以上三个概念；所以OSI的协议更有隐蔽性，协议更容易被替换</p></li><li><p>OSI由于没有考虑网络互连的问题，推行不是很方便；TCP/IP模型非常切合其本身协议，但其他协议栈不支持</p></li><li><p>最明显的就是层数不同……</p></li><li><p>OSI的网络层同时支持无连接和面向连接的通信，传输层只支持面向连接的通信；这由该层的特点所决定，因为传输服务对于用户可见</p></li><li><p>TCP/IP在网络层只支持无连接，传输层支持两种通信模式（TCP and UDP )，可以给用户选择的机会，对于简单的“请求-应答”协议特别重要</p></li></ul><p><strong>两种模型的评价</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155624.png" style="zoom:55%;" /><hr><h3 id="网络标准化"><a href="#网络标准化" class="headerlink" title="网络标准化"></a>网络标准化</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155751.png" style="zoom:60%;" /><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><p><strong>向网络层（即链路层的上一层）提供的服务种类</strong></p><ol><li>提供面向无连接的服务且不带确认，如以太网（差错率较低的环境）；</li><li>提供面向无连接的服务且带确认，如802.11无线网络（差错率较高）</li><li>带确认的面向连接服务</li></ol><h4 id="成帧方法"><a href="#成帧方法" class="headerlink" title="成帧方法"></a>成帧方法</h4><ol><li>字节计数    2. 带字节填充的首尾定界符法     3. 带比特填充的首尾定界符法    4.  物理层编码违例法</li></ol><p><strong>对于字节填充</strong></p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>如：检错码    前向纠错码    重传机制</p><p><strong>流量控制</strong></p><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><ul><li><p>海明距离的计算</p></li><li><p>最小海明距离和<em>纠错个数</em>，以及<em>查错个数</em>的关系</p><p>海明码编码规则，以及通过海明码来纠正单位错误</p></li></ul><p><strong>interleaving</strong> 编码样式</p><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>奇校验、偶校验        interleaving</p><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>校验和的计算</p><p>例：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211021235948.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211022000006.png"></p><p>前面多出的10加到0100上，相应得到二进制位串，接下去进行取反（0110）取反得到（1001），对应十进制数为9。在进行一波验证：</p><p>如图所示</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211022000459.png"></p><p>接收方的检验：把含校验和的字段和之前的被校验的数据共同求和，之后取反。若答案为0，则检测出没有错误（不代表没有错误，因为Internet Checksum的局限性）</p><h4 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h4><h3 id="基本的数据链路层协议"><a href="#基本的数据链路层协议" class="headerlink" title="基本的数据链路层协议"></a>基本的数据链路层协议</h3><blockquote><p>重点掌握<strong>PAR(Positive Acknowledgement with Retransmission)/ARQ（Automatic Repeat reQuest）方法。</strong></p></blockquote><p>ARQ方法 又叫 PAR方法</p><p>出现问题的只会在一帧和他的前一帧或后一帧；不会跨越两帧或更多。所以用一位序号（0 or 1）即可解决问题。在任何一个时刻，接收方期望接收下一个特定的序号。当包含正确序号的帧到来时，它被接受下来并且被传递给网络层。然后，接收方期待的下一个序号相应的发生变化（遵循模2增1）。任何一个到达的帧，如果包含了错误的序号将作为重复帧而遭到拒绝。但最后一个有效的确认应被重复，以便发送方确定已接收成功的帧。</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211027164751.png" alt="课件中的图例"></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>有两种基本方法用来处理管道化传输中出现的错误。</p><h4 id="Go-Back-N-（回退N）"><a href="#Go-Back-N-（回退N）" class="headerlink" title="Go-Back-N （回退N）"></a>Go-Back-N （回退N）</h4><p>接收方只需要简单丢弃后续到达的帧，并且对这些丢弃的帧不进行返回确认。这种策略对应于<strong>接收窗口大小为1</strong>的情形。如果信道的错误率很大，这种方式会浪费大量的带宽</p><p>如下图所示, 第二帧没有正确的接收（可能丢失或损坏）。发送方继续发送后续的帧，直到2号帧的计时器超时，然后退回到二号帧开始重发。</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211027201614.png" alt="回退N"></p><h4 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h4><p>采用这种策略，接收方将坏帧丢弃，但缓存接下来的所有好帧。等到发送方超时，重传对应帧并最后成功到达后，将缓存的好帧递交给网络层。这种方式对应的<strong>接收方窗口大于1</strong>，如果窗口很大，则该方法对数据链路层的内存需求很大。</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211027202506.png"></p><h4 id="发送-接收窗口大小"><a href="#发送-接收窗口大小" class="headerlink" title="发送/接收窗口大小"></a>发送/接收窗口大小</h4><ol><li><p>对于<strong>回退N方法</strong>，如果说存在十六个不同的序号（二进制表示占4位），那么发送的帧最多是15个。<strong>发送窗口大小的最大值必须严格小于序号个数的大小。</strong></p><p>而<strong>接受窗口的大小必须是1</strong></p><p><del><em>如果设发送最多帧数为 MAX_SEQ个</em></del></p></li><li><p>对于<strong>选择性重传方法</strong>，接收窗口的最大尺寸应该不超过序号空间的一半。比如用三位来表示序号（也就是八个序号），接收窗口的大小最大为4。同时接收方的缓冲区、计时器数量也是等于接收窗口的大小 <del>（一般来说是（MAX_SEQ + 1)/2 个）</del></p><p><strong>同时注意：发送窗口不能比接收窗口大！！</strong>，否则有可能会溢出。所以对于选择性重传方法，发送窗口的最大值也是序号空间大小的一半！</p></li></ol><h3 id="数据链路层协议示例"><a href="#数据链路层协议示例" class="headerlink" title="数据链路层协议示例"></a>数据链路层协议示例</h3><ol><li><strong>HDLC</strong> (High-level Data Link Control)</li></ol><ol start="2"><li><p><strong>PPP</strong> (Point-to-point Protocol)</p><p>面向字节的协议</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>课内复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP 阅读</title>
    <link href="/2021/09/29/2021-09-16-OSTEP-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/09/29/2021-09-16-OSTEP-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="OSTEP阅读笔记"><a href="#OSTEP阅读笔记" class="headerlink" title="OSTEP阅读笔记"></a>OSTEP阅读笔记</h1><h2 id="进程调度-chapter-7"><a href="#进程调度-chapter-7" class="headerlink" title="进程调度(chapter 7)"></a>进程调度(chapter 7)</h2><h3 id="衡量的调度指标"><a href="#衡量的调度指标" class="headerlink" title="衡量的调度指标"></a>衡量的调度指标</h3><ol><li><p>周转时间</p><p>T周转时间 = T完成时间 - T到达时间</p><p>假设所有任务同时到达，可设到达时间= 0</p></li><li><p>响应时间</p><p>T响应时间= T首次运行- T到达时间</p></li></ol><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>计算周转时间的例子，见下图</p><h3 id="SJF-最短任务优先"><a href="#SJF-最短任务优先" class="headerlink" title="SJF 最短任务优先"></a>SJF 最短任务优先</h3><p>在任务不同时到达时，存在问题。</p><h3 id="STCF-最短完成时间优先"><a href="#STCF-最短完成时间优先" class="headerlink" title="STCF 最短完成时间优先"></a>STCF 最短完成时间优先</h3><p>还有个名字 <em>抢占式最短作业优先</em></p><p>每当新工作进入系统时，就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作</p><p><em>以上的都是针对周转时间的优化方法</em></p><p>接下来是对于响应时间敏感程序的调度</p><hr><h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><p>Round-Robin, RR</p><p>时间片越短，RR在响应时间上表现越好；但是时间片过短，会导致上下文切换的成本过高，影响整体性能。所以系统设计者需要权衡时间片的长度，从而摊销上下文的切换成本。</p><h3 id="如果结合I-O来看……？"><a href="#如果结合I-O来看……？" class="headerlink" title="如果结合I/O来看……？"></a>如果结合I/O来看……？</h3><p>之前的情况都没有结合I/O读写，那么就有了<em>重叠</em>（overlap）操作</p><p>见下图</p><hr><h2 id="多级反馈队列（MLFQ）-chapter-8"><a href="#多级反馈队列（MLFQ）-chapter-8" class="headerlink" title="多级反馈队列（MLFQ）(chapter 8)"></a>多级反馈队列（MLFQ）(chapter 8)</h2><blockquote><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术 （同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶 段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。(OSTEP 第57页)</p></blockquote><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>MLFQ中有很多独立队列，他们有不同的优先级。任何时刻，一个工作只可能存在于一个队列中。MLFQ总是优先执行较高优先级的工作。</p><p>如果一个队列中有多个工作，则使用RR（轮转调度）的方式进行。</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215215.png" alt="书本P58" style="zoom:100%;" /><h3 id="优化的开始……？"><a href="#优化的开始……？" class="headerlink" title="优化的开始……？"></a>优化的开始……？</h3><h4 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h4><p>工作进入系统时，放入最高优先级；用完整个时间片后，降低优先级（进入别的队列）；如果是在时间片内主动释放CPU，优先级不变（比如时间片内进行I/O读写）</p><p>简单的几个例子：</p><p><strong>单个长工作</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215626.png"></p><p><strong>加了个短工作</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215742.png"></p><p>将一个新来的任务默认为短任务；并把它置于最高优先级。（长时间的工作，优先级一般都在最底下了……）</p><p>在上图这种情况下，类似于SJF，即最短任务优先的情况；如果说不是一个短任务，其优先级也会逐渐降级。（最后有可能进入队列Q0）</p><p><strong>考虑I/O呢？</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916220239.png" alt="书本P59"></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916220307.png" style="zoom:120%;" /><h3 id="上述方案存在的一些问题"><a href="#上述方案存在的一些问题" class="headerlink" title="上述方案存在的一些问题"></a>上述方案存在的一些问题</h3><ol><li><p>如果遇到很多I/O读取的程序，长时间的程序有可能就没机会使用CPU资源，就饿死了。</p></li><li><p>存在一些程序花里胡哨，使用欺骗手段。<strong>比如说</strong></p><p>​    在一个时间片快结束的时候发起一个I/O读写，从而继续顺利占领最高优先级，达到几乎”独占“使用CPU资源。</p></li></ol><h3 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h3><p>针对之前的一些问题，（比如有工作饿死等等）有了以下的继续尝试</p><h4 id="周期性提升优先级"><a href="#周期性提升优先级" class="headerlink" title="周期性提升优先级"></a>周期性提升优先级</h4><p><img src="C:/Users/Junjie1108/AppData/Roaming/Typora/typora-user-images/image-20210916221158748.png" alt="书本P60"></p><p>当然，仍存在着一些问题……这个时间段S怎么确定下来呢？过长导致长工作仍会”饿“；过短的话，交互性工作得不到合适的CPU时间比例。这个值也被<em>John Ousterhout</em>称为 Voo-doo constant </p><h4 id="进行进程消耗时间的统计"><a href="#进行进程消耗时间的统计" class="headerlink" title="进行进程消耗时间的统计"></a>进行进程消耗时间的统计</h4><p><em>这是之前所提的针对的程序欺骗的情形，所采取的手段</em></p><p>调度程序去记录一个进程在某一个层级所消耗的总时间；而不是调度时重新计时。（这里不管进程是一次性用完的，还是分好几次用完的）</p><p>对比如下图所示</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916221829.png" alt="image-20210916221829365"></p><h3 id="MLFQ调优及其他问题"><a href="#MLFQ调优及其他问题" class="headerlink" title="MLFQ调优及其他问题"></a>MLFQ调优及其他问题</h3><p>……</p><p><em><strong>配置多少队列？队列的时间片配置多大？提升优先级的S时间段大小又怎么定？</strong></em></p><p>……</p><p>其实可以，在高优先级的队列中使用较短的时间片，适合交互工作更快切换；低优先级队列的时间片更长，更适合需要CPU资源的进程进行工作。</p><p>还有些规则使用数学公式计算，期望的估计进行进程优先级的切换。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916222941.png" alt="书本P63"></p><blockquote><p>MLFQ 以史为鉴：关注进程的一贯表现，然后区别对待。</p><p>操作系统应 尽可能多地使用建议（advice），在进程调度，还有其他的各个领域，也有类似的方式。</p></blockquote><h2 id="比例份额调度"><a href="#比例份额调度" class="headerlink" title="比例份额调度"></a>比例份额调度</h2><h3 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h3><p><em>通过彩票调度，来进行CPU资源的划分；一个进程拥有的彩票数站总彩票书的百分比，就是它占有资源的份额</em></p><blockquote><p>彩票调度的精髓在于：利用随机性。传统的一些算法（比如LRU替换策略），可能在一些负载下表现非常差，但随机方法就不会。</p><p>其次，他很轻量，不需要记录状态，进程运行的时间等等。</p><p>另外，它很快。只要随机数产生的快就行了）</p></blockquote><p><em>如果需要用某种机制来表示所有权比例，这个概念可能就是彩票。</em></p><h3 id="一些机制"><a href="#一些机制" class="headerlink" title="一些机制"></a>一些机制</h3><p>彩票货币；彩票转让；彩票通胀</p><p>彩票货币，见P66</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210918195615.png"></p><p>彩票转让    </p><p>​    一个进程临时将自己的彩票转交给另一个进程；这种机制在Client/Server交互场景中有用。</p><p>​    在这种场景中，客户端进程给服务端发送消息，按自己需求进行工作，为了加速服务端执行，客户端可以选择转让彩票给服务端。服务端执行结束后会将这部分彩票还给客户端。</p><p>彩票通胀</p><p>​    一个机制可以临时提升或降低自己的彩票数量（前天要求进程间相互信任）</p><p>在这种情况下，一个进程知道自己需要更多CPU时间，则可以不与其他进程通信，直接进行与OS的告知。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p></blockquote><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929231657.png" alt="P67"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929231736.png"></p><h3 id="特点-以及-问题"><a href="#特点-以及-问题" class="headerlink" title="特点 以及 问题"></a>特点 以及 问题</h3><p>一个特点：只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。（也就是比较公平）</p><p><strong>问题在于</strong>:到底怎么为工作分配彩票呢？</p><h3 id="新引入：步长调度算法"><a href="#新引入：步长调度算法" class="headerlink" title="新引入：步长调度算法"></a>新引入：步长调度算法</h3><blockquote><p>你可能还想知道，究竟为什么要利用随机性？从上面的内容可以看出，虽然随机方式 可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作 运行时间很短的情况下。由于这个原因，Waldspurger 提出了步长调度（stride scheduling），<br>一个确定性的公平分配算法[W95]。</p></blockquote><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929232322.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929232352.png"></p><p>最终每个进程的运行次数恰好是票数的比例。彩票调度算法只能一段时间后，在概率上实现比例，步长调度算法可以在每个调度周期后做到完全正确。</p><p>但，<strong>彩票调度的优势在于</strong>——不需要全局状态。</p><p>当一个新进程中途进入，步长调度算法对于该新进程，如何设置行程值呢？而彩票调度只需要将票数加入总票数再进行计算即可。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这两种比例份额调度的算法，都没有作为CPU调度程序广泛使用，因为没有对于I/O进行很好的处理。但这种算法在容易确定比例份额的领域更有用（比如虚拟机分配资源）。</p><h2 id="抽象：地址空间"><a href="#抽象：地址空间" class="headerlink" title="抽象：地址空间"></a>抽象：地址空间</h2><h3 id="多道程序和时分共享"><a href="#多道程序和时分共享" class="headerlink" title="多道程序和时分共享"></a>多道程序和时分共享</h3><p>在进程切换的时候，我们将进程信息放在内存中，这样操作系统可以更有效率地实现时分共享。如下图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929233401.png"></p><p>假设只有一个进程，那么操作系统选择运行其中一个进程，其他的进程在队列中等待运行。</p><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929233521.png"></p><p>虚拟内存的三个主要目标：透明<em>transparency</em>,效率<em>efficiency</em>,保护<em>protection</em></p><p>程序不应感受到内存被虚拟化；操作系统应该保证在时、空两个维度上尽可能高效（在此过程中不得不依靠硬件支持，包括TLB的硬件功能）；保护进程之间互不干扰影响（关键概念：隔离）</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP-动态规划学习（1）</title>
    <link href="/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <url>/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划学习（1）"><a href="#动态规划学习（1）" class="headerlink" title="动态规划学习（1）"></a>动态规划学习（1）</h1><p>我这个铁fw直到要大二了，才开始着手算法部分的复习（其实是学习QAQ）</p><hr><h2 id="动态规划的思考方法"><a href="#动态规划的思考方法" class="headerlink" title="动态规划的思考方法"></a>动态规划的思考方法</h2><p>这一方法来自于AcWing社区的创始人yxc，是y总特别教学的dp问题分析大法</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>例题：AcWing 02，下附链接</p><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><p><strong>题目描述</strong></p><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; N,V &lt;= 1000;    0&lt; Vi , Wi &lt;= 1000;</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改进为一维后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= v[i]; j --)<span class="hljs-comment">//这边进行了一个逆向</span><br>        &#123;<br>        <span class="hljs-comment">//    f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//    if(j &gt;= v[i])</span><br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="最大子序列和-ex-Leetcode-53"><a href="#最大子序列和-ex-Leetcode-53" class="headerlink" title="最大子序列和 (ex. Leetcode_53)"></a>最大子序列和 (ex. Leetcode_53)</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="codes-1"><a href="#codes-1" class="headerlink" title="codes:"></a>codes:</h4><p>方法一：（动态规划朴素）</p><p><code>int f[i]</code> 代表以 num[i]为结尾的子序列和，探寻<code>f[i]</code>和<code>f[i-1]</code>的递推关系式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=53 lang=cpp</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [53] 最大子序和</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> MIN = <span class="hljs-number">-1e8</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> f[N];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N ; i ++)    f[i] = MIN;<br><br>        <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        f[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)<br>            f[i] = <span class="hljs-built_in">max</span>(nums[i], f[i<span class="hljs-number">-1</span>] + nums[i]);<br>        <br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1e8</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><p>方法二：    Kadane算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> MIN = <span class="hljs-number">-1e8</span>;<br>    <span class="hljs-keyword">int</span> ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> sig = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i ++)<br>        &#123;<br>            temp += nums[i];<br>            <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">0</span>)<br>                temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(ans &lt; temp)<br>            &#123;<br>                ans = temp;<br>                sig = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!sig)<br>        &#123;<br>            ans = MIN;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i ++)<br>                ans = <span class="hljs-built_in">max</span>(ans, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列和"><a href="#最长上升子序列和" class="headerlink" title="最长上升子序列和"></a>最长上升子序列和</h3><p>相关题目    PAT A1007</p><p>给定一个数字序列A1，A2，A3……An，求i, j，使得Ai + ……+ Aj 最大，输出这个最大值</p><p><strong>输入样例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">10<br><span class="hljs-string">-10</span> 1 2 3 4 <span class="hljs-string">-5</span> <span class="hljs-string">-23</span> 3 7 <span class="hljs-string">-21</span><br>0<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="codes-2"><a href="#codes-2" class="headerlink" title="codes:"></a>codes:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> f[N];<br><span class="hljs-keyword">int</span> s[N];<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>  i = <span class="hljs-number">1</span> ;i &lt;= k ; i ++)<br>            &#123;<br>                cin &gt;&gt; a[i];<br>                <span class="hljs-keyword">if</span>(a[i] &gt;= <span class="hljs-number">0</span>)   flag = <span class="hljs-literal">true</span>;<br>            &#125;    <br> <br>            <span class="hljs-keyword">if</span>(!flag)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[k] &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br> <br>            f[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>] + a[i] &gt; a[i])<br>                &#123;<br>                    f[i] = f[i<span class="hljs-number">-1</span>] + a[i];<br>                    s[i] = s[i<span class="hljs-number">-1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    f[i] = a[i];<br>                    s[i] = i;<br>                &#125;<br>            &#125;<br> <br>            <span class="hljs-keyword">int</span> ind = <span class="hljs-number">0</span>;<br> <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[ind] &lt; f[i])<br>                    ind = i;<br>            &#125;<br> <br>            cout &lt;&lt; f[ind] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[s[ind]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[ind] &lt;&lt; endl; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长不下降子序列（递增子序列）"><a href="#最长不下降子序列（递增子序列）" class="headerlink" title="最长不下降子序列（递增子序列）"></a>最长不下降子序列（递增子序列）</h3><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1≤N,M≤1000</p><p><strong>输入样例</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">abcd</span><br><span class="hljs-attribute">abedc</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h4 id="codes-3"><a href="#codes-3" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">char</span> a[N];<br><span class="hljs-keyword">char</span> b[N];<br><span class="hljs-keyword">int</span> n , m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; a+<span class="hljs-number">1</span> &gt;&gt; b+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m ; j ++)<br>       &#123;<br>       f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span>(a[i] == b[j])<br>           f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大写字母。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少操作次数。</p><p><strong>数据范围</strong></p><p>1≤n,m≤1000</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">10 <br>AGTCTGACGC<br>11 <br>AGTAAGTAGGC<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="codes-4"><a href="#codes-4" class="headerlink" title="codes"></a>codes</h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithms</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(4)</title>
    <link href="/2021/08/28/2021-08-28-CPP-OPP-review(4)/"/>
    <url>/2021/08/28/2021-08-28-CPP-OPP-review(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-4"><a href="#CPP-OPP-review-4" class="headerlink" title="CPP-OPP review(4)"></a>CPP-OPP review(4)</h1>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP 补充</title>
    <link href="/2021/08/04/2021-08-04-CPP-OPP-%E8%A1%A5%E5%85%85/"/>
    <url>/2021/08/04/2021-08-04-CPP-OPP-%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-补充知识"><a href="#CPP-OPP-补充知识" class="headerlink" title="CPP-OPP 补充知识"></a>CPP-OPP 补充知识</h1><h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 <code>static</code></h2><ol><li>添加了<code>static</code>关键字的成员数据跟对象就脱离了，在内存中有独立的一块空间分配给他。</li><li>添加了<code>static</code>关键字的成员函数也是在内存中只保留一份（和<code>class</code>中的普通函数一样，只保存一遍）</li></ol><p>所以，<code>static</code>就是用来给，和对象没有绑定关系的不变变量使用</p><p>而<code>static</code>成员函数因为没有<em>this-pointer</em>，也是只能处理<code>static</code>数据</p><p>class的<code>static</code>变量，在class的声明之后，需要有一行<em>Definition</em> 定义，如图所示</p><p>调用<code>static</code>函数有两种方式：</p><ol><li>通过object调用 </li><li>通过class name 调用</li></ol><h2 id="把构造函数放在private区域内"><a href="#把构造函数放在private区域内" class="headerlink" title="把构造函数放在private区域内"></a>把构造函数放在<code>private</code>区域内</h2><p><strong>Singleton</strong>模式</p><h3 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h3><h2 id="类模板-和-函数模板"><a href="#类模板-和-函数模板" class="headerlink" title="类模板 和 函数模板"></a>类模板 和 函数模板</h2>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 21/8/4</title>
    <link href="/2021/08/04/2021-08-04-LeetCode-2184/"/>
    <url>/2021/08/04/2021-08-04-LeetCode-2184/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-21-8-4"><a href="#LeetCode-21-8-4" class="headerlink" title="LeetCode 21/8/4"></a>LeetCode 21/8/4</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2>]]></content>
    
    
    
    <tags>
      
      <tag>algorithms</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(3)</title>
    <link href="/2021/07/22/2021-07-20-CPP-OPP-review(3)/"/>
    <url>/2021/07/22/2021-07-20-CPP-OPP-review(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-3"><a href="#CPP-OPP-review-3" class="headerlink" title="CPP-OPP review(3)"></a>CPP-OPP review(3)</h1><p>A <strong>BIG THREE</strong>:</p><ol><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>析构 </li></ol><p>有指针成员的函数，必须要有拷贝构造+拷贝赋值  </p><p>否则就产生多重引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __MYSTRING__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __MYSTRING__</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:                                 <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr=<span class="hljs-number">0</span>);                     <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);                    <br>   String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);         <br>   ~<span class="hljs-built_in">String</span>();                                    <br>   <span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (cstr) &#123;<br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//动态分配内存， +1因为包括结束符</span><br>      <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;   <br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];<br>      *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//注意这里是*m_data</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//注意这里是delete[]，而不是delete</span><br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<span class="hljs-comment">//拷贝赋值</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//&amp;符号的含义结合具体情况，加在类型后面就是引用，</span><br>       <span class="hljs-comment">//如果加在变量名前，就是取地址</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这种情况检验自我赋值。例如s1 = s1;</span><br>    <span class="hljs-comment">//特殊情况特殊处理</span><br><br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//先delete，再分配空间+拷贝</span><br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String&amp; str)</span><span class="hljs-comment">//拷贝构造</span></span><br><span class="hljs-function"></span>&#123;<br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br>   os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();<br>   <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723231933.png" alt="构造函数 和 析构函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232041.png" alt="拷贝构造"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232232.png" alt="拷贝赋值函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232327.png" alt="自我赋值造成可能的危险"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232632.png" alt="new 申请空间"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232713.png" alt="delete 释放空间"></p><p><code>new</code>实际上先申请了一部分内存，在进行构造</p><p><code>delete</code>则反过来，先调用析构函数，再释放内存</p><hr><p>接下来是底层的内存分配示意图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233051.png"></p><p>红色部分是 <em>cookie</em>，各占四个字节；灰色部分是 <em>debugger header</em>，以及<em>no man land</em>，当然还有内存对齐所需要的空间。    从52到64，是为了让申请的内存块大小达到16Byte的倍数。</p><p>之后的图片说明了，<code>delete</code>和<code>delete[]</code>的区别：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233633.png" alt="delete的使用"></p><p>确实会造成<strong>memory leak</strong>，但其实是打<strong>？！</strong>的内存区域没有被回收，而不是想象中的<strong>21h</strong>部分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(2)</title>
    <link href="/2021/07/20/2021-07-20-CPP-OPP-review(2)/"/>
    <url>/2021/07/20/2021-07-20-CPP-OPP-review(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-2"><a href="#CPP-OPP-review-2" class="headerlink" title="CPP-OPP review(2)"></a>CPP-OPP review(2)</h1><ol><li><p>操作符重载，可分为：<strong>成员函数</strong>（含<code>this</code>指针）和<strong>非成员函数</strong>。</p></li><li><p>临时对象，例如之前所写的<code>complex</code>类,<code>complex(2,1)</code>创建一个 **2 + i ** 的复数临时对象。如果在成员函数当中被临时创建，注意使用 <em>return by value</em> , 因为在函数中创建的对象是 <em>local</em> 的，临时的。</p></li><li><p>输入输出流作为参数不可以作为<code>const</code>传入</p></li><li><p>一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么返回的是<code>ostream&amp;</code>，而不是<code>void</code>？</p><p>因为很常见的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; c1;<span class="hljs-comment">//void 还是ostream&amp;返回 都可以</span><br>cout &lt;&lt; c1 &lt;&lt; c2;<span class="hljs-comment">//假设是这种情况，void返回就不行。</span><br></code></pre></td></tr></table></figure><hr></li></ol><p><strong>总结</strong></p><p><strong>initialization list</strong>的使用；函数参数考虑，尽量用<em>pass_by_reference</em>；函数参数考虑是否要加<code>const</code>；函数返回值考虑是否用<em>pass_by_reference</em>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(1)</title>
    <link href="/2021/07/18/2021-07-18-CPP-OPP-review(1)/"/>
    <url>/2021/07/18/2021-07-18-CPP-OPP-review(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-1"><a href="#CPP-OPP-review-1" class="headerlink" title="CPP-OPP review(1)"></a>CPP-OPP review(1)</h1><p>这个<em>review</em>系列是本人观看侯捷老师的面向对象的讲解视频，并结合 <em>effective C++</em> 这本经典书籍，进行的一些知识点的零散记录。</p><hr><ol><li><p>class中的成员函数，默认成为<code>inline</code>函数的候选</p></li><li><p>外部的函数想要成为<code>inline</code>，需要加关键字<code>inline</code></p></li><li><p>构造函数的写法：</p><ol><li><p>赋值写法</p></li><li><p>运用<strong>初值列</strong>(<em>initialization list</em>),进行初始化</p><p>这两种的区别是，构造函数先进行初始化，再进行{}内部的操作，用<em>initialization list</em>更有效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re, im;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>构造函数允许有很多个 - <strong>overloading</strong></p><p><em>但如果出现以下的例子，则not allowed</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<span class="hljs-comment">//这里不需要加分号了</span><br><span class="hljs-built_in">complex</span>():<span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>)&#123;&#125;<span class="hljs-comment">//与上面一个构造函数冲突</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">double</span> re, im;<br></code></pre></td></tr></table></figure></li><li><p>构造函数也有可能写在<code>private</code>中，这种模式叫做<em>singleton</em>.</p></li><li><p>在写成员函数的时候，就需要考虑好，是否需要加上<code>const</code>.<strong>该加上就要加上！</strong></p></li><li><p>尽可能多用<em>pass-by-reference</em>，pass-by-value(to const)需要将数据 <em>打包</em> 压入栈，（可能爆栈）</p></li><li><p>相同<code>class</code>的各个对象互为友元，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex &amp;pra)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (pra.re + pra.im);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re , im;<br>&#125;;<br><br><span class="hljs-comment">//////////以下为main函数///////</span><br>&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    c2.<span class="hljs-built_in">func</span>(c1);<span class="hljs-comment">//实部虚部相加 </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/12_随记</title>
    <link href="/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-12-随记"><a href="#CPP-面向对象-21-7-12-随记" class="headerlink" title="CPP 面向对象 21/7/12 随记"></a>CPP 面向对象 21/7/12 随记</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>使用了<code>new</code>或指针的相同类或结构体的对象间，不能使用 = 进行赋值操作，必须对 = 进行了操作符重载后，才能赋值。否则两个类的指针指向相同的内存地址。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>分为<code>public</code>继承和<code>private</code>继承 （还有<code>protected</code>继承）</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210713082837.png"></p><p>派生类的访问权限由基类+继承类型 <em>取小</em> 得到。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超频一时爽，系统崩溃死机火葬场</title>
    <link href="/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/"/>
    <url>/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="这周末的作死，让我对OverClock产生了阴影……"><a href="#这周末的作死，让我对OverClock产生了阴影……" class="headerlink" title="这周末的作死，让我对OverClock产生了阴影……"></a>这周末的作死，让我对OverClock产生了阴影……</h1><p>另外自己也不应该买es的CPU，在bios自检不通过的情况下，也没有妥善处理。</p><p>感谢msi，感谢Intel，感谢巨硬。也感谢    <strong>自己作大死！</strong></p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/8_随记</title>
    <link href="/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-07-08"><a href="#CPP-面向对象-21-07-08" class="headerlink" title="CPP 面向对象  21/07/08"></a>CPP 面向对象  21/07/08</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ol><li><p> <code>enum</code> <strong>枚举类型变量</strong></p></li><li><p><code>struct</code><strong>类型</strong></p><p>对于<code>struct</code>整体进行操作，可行的有：</p><ol><li>给同一<code>struct</code>类型的对象赋值（值传递或引用传递）</li><li>作为函数参数返回</li></ol></li><li><p><code>class</code><strong>类型</strong></p><ol><li><p>该类型中有两种成员： 数据成员 和 函数成员</p></li><li><p>成员默认为<code>private</code>，这一点和<code>struct</code>类型不同</p></li><li><p>函数成员大多应该声明为public类型</p></li><li><p><code>private</code>类型成员无法被外部访问，只能被该<code>class</code>成员函数 和 友元 访问</p></li><li><p>（默认）构造函数</p></li></ol></li></ol><hr><p><em>以下更新于2021.7.9</em></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><blockquote><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><p>内联函数一般用于能够快速执行的函数，对于很小的函数也有空间上的溢出。</p><p>内联函数是在函数原型的前面加上<code>inline</code>限定符, 例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt; y)?x:y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(20,10): &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(100,1010)： &quot;</span>&lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1010</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><p>内联函数是为了解决函数调用的效率问题。编译的时候，调用式用函数体进行替换；而其他的函数都是在运行的时候才被替代。    故实际上是通过<strong>空间换时间</strong>。以下有几个注意点：</p><ol><li>循环语句，开关语句不允许出现</li><li>内联函数的定义，需要出现在函数第一次调用之前</li><li>类结构中所在的类说明内部定义的函数是内联函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++》 阅读随记</title>
    <link href="/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读《Effective-C-》第一章"><a href="#读《Effective-C-》第一章" class="headerlink" title="读《Effective C++》第一章"></a>读《Effective C++》第一章</h1><h2 id="C-是一个语言联邦"><a href="#C-是一个语言联邦" class="headerlink" title="C++是一个语言联邦"></a>C++是一个语言联邦</h2><p>C++是一个多重范型(muitiparidigm)语言，其支持：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>次语言(sublanguage)：C, Object-Oriented C++, Template C++, STL</p><p>正因如此，高效编程需要随着编程者切换次语言来采取不同的守则、通例。</p><h2 id="用-const-enum-inline-替换-define"><a href="#用-const-enum-inline-替换-define" class="headerlink" title="用 const enum inline 替换 #define"></a>用 <code>const</code> <code>enum</code> <code>inline</code> 替换 <code>#define</code></h2><ol><li><p>对于常量</p><p>例如：<code>#define ASPECT_RATIO 1.653</code> 该记号名称也许从未被编译器看见，很可能在编译器处理源码之前，就被预处理器移走。这样的后果：ASPECT_RATIO 有可能未进入 symbol table （<em><strong>注：符号表等概念可以查阅CSAPP第七章</strong></em>）。于是一旦发生编译错误，可能就因此让编程者产生困惑。</p><p>解决方法：用常量替换一个上述的宏</p></li></ol><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708142830.png" style="zoom:80%;" /><p>​        两种特殊情况：</p><p>​        <strong>常量指针</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143130.png" style="zoom:80%;" /><p>​        <strong><code>class</code>专属常量</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143415.png" style="zoom:80%;" /><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143755.png" style="zoom:80%;" /><p>​        <strong>enum hack</strong> 技术，能够避免出现可能的（编译器不够优秀）为“整数型const对象” 进行内存分配</p><p>​        <strong>enum hack</strong> 技术，是模板元编程的基础技术。</p><ol start="2"><li>用<code>inline</code> 替代macro</li></ol><p>（暂时略……）</p><p><strong>总结</strong></p><blockquote><p>对于单纯常量，最好以const对象 或 enum 替换 #define</p><p>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</p></blockquote><h2 id="尽可能使用-const"><a href="#尽可能使用-const" class="headerlink" title="尽可能使用 const"></a>尽可能使用 <code>const</code></h2><p><code>const</code>关键字允许指定一个语义约束（说人话就是指定一个改动不了的对象）</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190027.png"></p><p><strong><code>const</code> 若出现在星号左边，表示被指物为常量；在星号右边，表示指针是常量；如果星号两边都有<code>const</code>,说明被指对象和指针本身都是常量。</strong></p><p>注：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190839.png"></p><hr><p>对于STL迭代器的<code>const</code>，和命名指针(T类型的指针, <code>T*</code>)类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// iter的作用类似于 T* const</span><br><span class="hljs-comment">//指向的东西必须一样，但东西的值可以改变</span><br>*iter = <span class="hljs-number">10</span>;<span class="hljs-comment">//ok</span><br>iter ++;<span class="hljs-comment">//not allowed</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// cIter的作用类似于 const T*  </span><br><span class="hljs-comment">//被指向的东西不得改变</span><br>*cIter = <span class="hljs-number">10</span>;<span class="hljs-comment">//not allowed</span><br>cIter ++;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>令函数返回一个常量值，往往可以能够降低因client端的错误而造成的意外。详细例子见书P19</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>这类函数重要，原因有两个：</p><ol><li><p>让class接口更好理解，client端知道哪个函数可以改变对象内容，而哪个不行。</p></li><li><p>让操作<code>const</code>对象成为可能，因为提升C++程序效率的一条原则：<em><strong>pass by reference to const</strong></em></p><p>这技术可行的前提：有<code>const</code>成员函数用来处理取得的<code>const</code>对象</p></li></ol><p>一个事实：如果两个函数只是常量性不同，可以被重载。</p><p>如图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215257.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215407.png"></p><p>因为<code>non-const operator[]</code>的返回类型是<strong>reference to char</strong>，不是<code>char</code>；如果返回的是<code>char</code>，该语句无法通过编译。因为函数如果返回类型是内置类型（如<code>int</code>,<code>char</code>,<code>bool</code>）, 改动返回值就是不合法的。</p><hr><p>还有两个概念<strong>logical constness</strong> 和 <strong>bitwise constness</strong> </p><p>后者支持者认为成员函数只有在不改变认为成员变量（除静态<code>static</code>变量以外）的情况下，才可以被称为<code>const</code>.</p><p>也就是不改动任何一个<strong>bit</strong>. 但却有很多函数符合该规则，却不是十足具备<code>const</code>性质，如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220107.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220127.png"></p><p>另一派支持：**<code>const</code>成员函数可以修改对象的某些bits，但要在客户端侦测不到的时候才得如此。**</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220438.png"></p><p>重要： <strong>用<code>mutable</code>“骗过”编译器</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220501.png"></p><h3 id="在const-和-non-const成员函数中避免重复"><a href="#在const-和-non-const成员函数中避免重复" class="headerlink" title="在const 和 non-const成员函数中避免重复"></a>在const 和 non-const成员函数中避免重复</h3><p><em>暂时略……反正<code>const</code>很强就完事了……</em></p><p><strong>总结：</strong></p><blockquote><p>将有些东西声明为<code>const</code>可以帮助编译器侦测出错误用法。 <code>const</code>可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><p>编译器强制实施 <strong>bitwise constness</strong>, 但实际编写程序应该使用“概念上的常量性”（比如使用mutable）</p><p>用<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>版本调用<code>const</code>版本可避免代码的重复。</p></blockquote><h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>《Effective C++》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/7_随记</title>
    <link href="/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-7"><a href="#CPP-面向对象-21-7-7" class="headerlink" title="CPP 面向对象 21/7/7"></a>CPP 面向对象 21/7/7</h1><h2 id="库-lt-fstream-gt-的使用，文件输入输出"><a href="#库-lt-fstream-gt-的使用，文件输入输出" class="headerlink" title="库&lt;fstream&gt;的使用，文件输入输出"></a>库<code>&lt;fstream&gt;</code>的使用，文件输入输出</h2><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-comment">/*...省略其余头文件...*/</span><br><br><span class="hljs-keyword">double</span> a;<br>string b;<br><span class="hljs-comment">//需要读入的变量</span><br><br>ifstream inFile;<br>ofstream outFile;<br><br>inFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;INPUT.txt&quot;</span>);<span class="hljs-comment">//此处为相对路径</span><br>outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;result.txt&quot;</span>);<span class="hljs-comment">//结果输出到 result.txt 文件中</span><br><br>inFile &gt;&gt; a &gt;&gt; b;<span class="hljs-comment">//读入</span><br><span class="hljs-comment">//同理输出到文件用outFile</span><br><br><span class="hljs-comment">/*关于文件流的使用，可以用 inFile,outFile 代替原有的 cin,cout*/</span><br><br>inFile.<span class="hljs-built_in">close</span>();<br>outFile.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭流</span><br><br><br></code></pre></td></tr></table></figure><p>如果输入流打开的文件有误（读取不合法，或文件路径错误等等），会产生输入流的挂起。这种情况在编写程序的时候需要特判    如<code>if(!inFile)  return 1;</code></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Don&#39;t program with COINCIDENCE.</title>
    <link href="/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/"/>
    <url>/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/6_随记</title>
    <link href="/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-6"><a href="#CPP-面向对象-21-7-6" class="headerlink" title="CPP 面向对象 21/7/6"></a>CPP 面向对象 21/7/6</h1><h2 id="C-语法知识"><a href="#C-语法知识" class="headerlink" title="C++语法知识"></a>C++语法知识</h2><p><strong>格式化输出setw(), setprecision()应用</strong></p><p>setw() 默认右对齐</p><p>eg. s和a之间有7个空格，cout&lt;&lt;’s’&lt;&lt;setw(8)&lt;&lt;’a’&lt;&lt;endl;的意思是s后面输出8个字符，其中a占一个字符，剩余7个字符用空格填充</p><p>setw()默认用空格填充，也可以用其他的字符填充，运用setfill()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">21</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706102918153.png"></p><p>如果需要左对齐，则在前面添加left，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &lt;&lt;  <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706104131423.png"></p><hr><p>setprecision() + fixed 控制精确到小数点后的位数</p><p><em><strong>补充：setfill()函数会永久更改填充空格的字符，下次重新用的时候注意初始化为所用的符号（默认的setw()填充为空格）</strong></em></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>类具有封装和信息隐藏的特性。只有<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">类的成员函数</a>才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a>，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。 </p><p>为了解决上述问题，提出一种使用友元的方案。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。(from baidu)</p></blockquote><ol><li><strong>友元函数</strong></li></ol><p>友元是定义在类外部的普通函数或类，但需要在<em><strong>类体中</strong></em>进行说明，用<code>friend</code>关键字加以说明。故友元函数的调用不需要对象表示，直接调用即可。</p><p>友元函数没有this指针，其参数分几种情况：</p><p>访问非static变量，需要对象作为参数；访问static成员或全局变量时，不需要对象做参数。</p><ol start="2"><li><strong>友元类</strong></li></ol><blockquote><p>友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的<a href="https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a>，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p></blockquote><p>格式：</p><p><code>friend class  </code> + 类名</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706131141197.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++复健（其实就是重学）</title>
    <link href="/2002/02/22/2002-02-22-C++%E5%A4%8D%E5%81%A5%EF%BC%88%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E9%87%8D%E5%AD%A6%EF%BC%89/"/>
    <url>/2002/02/22/2002-02-22-C++%E5%A4%8D%E5%81%A5%EF%BC%88%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E9%87%8D%E5%AD%A6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-复健，即重学"><a href="#C-复健，即重学" class="headerlink" title="C++复健，即重学"></a>C++复健，即重学</h1><h2 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h2><h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><p><strong>默认实参</strong></p><p>情形：一些函数的形参在许多次调用中被赋予一个相同的值，则可以将其（值）设为默认实参。调用这些函数时，可以包含这样的实参，也可以省略该实参。</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220223003654.png" alt="image-20220223003458897"></p><p>但有一点需要注意：<strong>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</strong></p><p>在调用这样的函数时，<strong>只能省略尾部（靠后的）的实参</strong>，那么就需要合理设置形参的位置，让不怎么使用默认值的形参出现在前面。</p><p><strong>（含）默认实参（函数的）声明</strong></p><p>一般把它放在头文件中，并且一个函数只声明一次；但是多次声明同一个函数也是合法的。但：<strong>函数的后续声明，只能为没有默认值的形参添加默认实参！！</strong>如下图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20220223004447.png" alt="image-20220223004447336"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
