<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络知识点梳理（课内）</title>
    <link href="/2021/10/21/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/"/>
    <url>/2021/10/21/2021-09-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%EF%BC%88%E8%AF%BE%E5%86%85%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h3><p>Computer network: a collection of autonomous computers interconnected by a single technology</p><ol><li><p>autonomous: be able to compute independently</p></li><li><p>interconnected: be able to exchange information</p></li></ol><p>Computer networks: collections of autonomous computers </p><p>​    例如：the Internet</p><p>Computer networks VS. Distributed systems:</p><ul><li>In distributed systems, a model on top of the network is used to present the independent computers to users as a single coherent system, e.g., the Web.</li><li>Who makes the decision?—- Users VS. OS</li></ul><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ul><li><p>按照传输技术</p><p>广播网络和点到点网络（单播）    Broadcast links and Point-to-point links</p></li><li><p>按照距离尺度</p><p>个域网、局域网、城域网、广域网和互联网</p><p>PAN        LAN        MAN        WAN</p></li></ul><h3 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h3><blockquote><p>本节需要掌握的内容包括：</p><p>1） 一组概念：对等体、协议、服务、接口、计算机网络体系结构、协议数据单元PDU、SDU；</p><p>2） 计算机网络协议分层的好处和缺点，通过协议分层实现数据封装及解封的过程；</p><p>3） 面向连接服务和面向无连接服务的特点及实现过程；</p><p>4） 面向连接与面向无连接VS.可靠与不可靠</p></blockquote><ol><li><p>服务：层间交换信息时必须遵守的规则。</p></li><li><p>接口：定义了下层向上层提供的原语操作和服务。</p></li><li><p>第N层协议：</p><ul><li><p>不知道上、下层的内部结构</p></li><li><p>独立完成某种功能</p></li><li><p>为上层提供服务</p></li><li><p>使用下层提供的服务</p></li></ul></li></ol><p><em>说人话就是上一层通过接口收到下一层送上门来的东西（大雾）</em></p><hr><p>有个具体的生活中的例子作为类比：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914000941.png" alt="哲学家-翻译-秘书层级"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210914001218.png" alt="协议分层"></p><ol><li><p>同一层级的通信，即水平通信（也是peer-to-peer的），属于虚拟通信</p></li><li><p>相邻层的通信是实际通信</p></li></ol><p><strong>一些概念：</strong></p><ul><li><p>服务访问点SAP（Service Access Point）</p><p>任何层间服务是在接口的SAP上进行的，每个SAP有唯一的识别地址</p><p>每个层间接口可以有多个SAP </p></li><li><p>接口数据单元IDU（Interface Data Unit）</p><p>IDU是通过SAP进行传送的层间信息单元</p><p>IDU由上层的服务数据单元SDU（Service Data Unit）和接口控制信息ICI（Interface Control Information）组成</p></li><li><p>协议数据单元PDU（Protocol Data Unit）</p><p>第N层实体通过网络传送给它的对等实体的信息单元</p><p>PDU由上层的服务数据单元SDU或其分段和协议控制信息PCI（Protocol Control Information）组成</p></li><li><p>服务数据单元SDU（Service Data Unit）</p><p>跨过网络传给对等实体并交给上层的信息</p></li></ul><blockquote><p>SDU（service Data Unit）:服务数据单元，又叫业务数据单元，是指定层的用户服务的数据集，传送到接收方的时候同一协议层时数据没有发生变化，即业务部分，然后发给下层之后，下层将其封装在PDU中发送出去。服务数据单元是从高层协议来的信息单元传送到低层协议。第N层服务数据单元SDU，和上一层的协议数据单元（PDU）是一一对应的。根据协议数据单元的数据的不同，送到接收端的指定层。</p><p>PDU（Protocol data unit）: 协议数据单元：<strong>计算机网络各层对等实体间交换的单位信息</strong>，例如TCP层的PDU就是segment（分节）、应用层间交换的PDU则是application data（应用数据）</p><p>转自： <a href="http://blog.csdn.net/wind19/article/details/4669637">http://blog.csdn.net/wind19/article/details/4669637</a></p></blockquote><p>存在公式：</p><p>PDU(N) = SDU(N - 1)</p><p>SDU(N) = PDU(N + 1)</p><p>对于某一层来说，收到的是SDU;</p><p>处理完出去的是PDU，那么对于下一层来说，这块PDU就是下一层的SDU</p><blockquote><p>N层用户与N层协议之间传递的数据称为服务数据单元(SDU)<br>N层协议实体之间传递的数据称为协议数据单元（PDU），通过数据发送/接收管理把用户提交的SDU以PDU的形式，通过下层通道发送到对端协议实体。在接收端再将PDU还原成SDU送给收端用户。<br>PDU的封装/解封装：在发送方，将用户递交的SDU加上协议控制信息PCI，封装成PDU；在接收方，讲接收到的PDU解封装，去掉PCI，还原成SDU送交接收方用户。<br>SDU分段/装配 ：如果下层通道的带宽不能满足传递SDU的需要，就需要将一个SDU分成多段，分别封装成PDU发送出去（分段）；在接收方再将这些PDU解封装后重新装配成SDU。<br>SDU拼接/分离：拼接是指在发送方(n)层协议实体把多个长度较短的(n)SDU封装成一个(n)PDU来发送，在接收放再将接收到的(n)PDU解封装，将多个(n)SDU分离出来。采用拼接功能的目的是提高通道的利用率。<br>PDU分割/组合：PDU分割是指在发送端(n)层协议实体把一个(n)PDU分割成多个(n-1)SDU，并行地从多个(n-1)通道发送出去；接收端再将收到的多个(n- 1)SDU组合成一个(n)PDU。由于这是一个N层功能，所以组合操作在N层中进行，即N层先得到多个分割开的(n)PDU，然后把它们组合成一个(n)PDU。</p><p>转自：<a href="https://blog.csdn.net/zhangxiao93/article/details/51253933">(52条消息) 网络通信PDU和SDU的区别_上善若水-CSDN博客_pdu sdu</a></p></blockquote><p>简而言之，一个SDU可能要封装在多个PDU中传输，    N层的PDU = N层的PCI + N层的SDU</p><hr><p><strong>网络协议分层的优缺点：</strong></p><ul><li>缺点：层次多，效率低</li><li>优点：层次间相互独立，无需知道相邻层次的具体完成细节；模块化维护方便，只需要接口、提供的service不变就可以；也容易进行复用。</li></ul><blockquote><p>Stanford CS144:</p><ol><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Separation of concerns</li><li>Continuous improvement</li><li>Peer-to-peer communications （eg. the Internet 使用互联网不需要考虑如何实现通信）</li></ol></blockquote><p><strong>面向连接和面向无连接</strong> &amp; <strong>可靠与不可靠</strong></p><p>见中文书本P27-29</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151244.png" style="zoom:80%;" /><hr><h3 id="服务与协议的关系"><a href="#服务与协议的关系" class="headerlink" title="服务与协议的关系"></a>服务与协议的关系</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151621.png" alt="书本P36 服务 vs. 协议" style="zoom:80%;" /><hr><h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p>博客园上有老哥做了一个OSI七层 和 TCP/IP五层模型的小总结，写的还不错</p><p>链接：<a href="https://www.cnblogs.com/qishui/p/5428938.html">OSI七层模型与TCP/IP五层模型 - SevenFormer - 博客园 (cnblogs.com)</a></p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915151739.png" style="zoom:60%;" /><p>——<em>上图需要注意通信子网协议边界，路由涉及到第三层，交换机涉及到第二层</em>——–</p><ol><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p><p>用户需要的各种各样的协议，例如HTTP（超文本传输协议）</p></li></ol><h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4><ol><li><p>链路层</p><ul><li>该层描述了链路必须完成什么功能，才能满足无连接的互联网络层的需求，比如串行线和经典以太网链路</li><li>这不是真正意义上的一个层，而是主机和传输线路的一个接口</li></ul></li><li><p>互联网层</p><ul><li>大致对应OSI网络层，该层任务是允许主机将数据包注入到任何网络，让这些数据包独立到达接收方（也许接收方在不同的网络上）（数据包到达顺序和发送顺序也可能不一）</li><li>这里的internet是指一般意义上的互联网络，非现在所说的<em>互联网</em>。</li><li>该层定义了官方数据包格式和协议，即IP协议，还有辅助协议因特网控制报文协议ICMP，该层还需要考虑拥塞控制问题（Congestion Control）</li></ul></li><li><p>传输层</p><ul><li>允许源主机和目标主机的对等实体进行对话，如同OSI传输层</li><li>定义有两个端到端的传输协议，分别是传输控制协议TCP 和 用户数据报协议 UDP</li></ul><p><strong>TCP:</strong></p><p>可靠、面向连接；还负责流量控制（接收方和发送方）；将输入的字节流分割成离散的报文，再传递给互联网层；在目标机器，接收TCP进程会把收到的报文重新装配到输出流中。（生活实际：下载文件）</p><p><strong>UDP:</strong></p><p>不可靠、无连接协议；广泛应用于一次性的客户机-服务器类型的“请求-应答”查询应用，以及<strong>及时交付</strong>更为重要的应用（比如传输语音或视频）</p></li><li><p>应用层</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154219.png" style="zoom:60%;" /></li></ol><h4 id="两种模型的共同点和不同点"><a href="#两种模型的共同点和不同点" class="headerlink" title="两种模型的共同点和不同点"></a>两种模型的共同点和不同点</h4><p><strong>共同点：</strong></p><ul><li>以协议栈概念为基础；协议栈中协议彼此独立；层功能大致相似</li></ul><p><strong>不同点：</strong></p><ul><li>OSI模型核心：服务；接口；协议。</li></ul><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915154914.png" alt="书本P38" style="zoom:60%;" /><ul><li><p>TCP/IP模型最初并没有明确区分以上三个概念；所以OSI的协议更有隐蔽性，协议更容易被替换</p></li><li><p>OSI由于没有考虑网络互连的问题，推行不是很方便；TCP/IP模型非常切合其本身协议，但其他协议栈不支持</p></li><li><p>最明显的就是层数不同……</p></li><li><p>OSI的网络层同时支持无连接和面向连接的通信，传输层只支持面向连接的通信；这由该层的特点所决定，因为传输服务对于用户可见</p></li><li><p>TCP/IP在网络层只支持无连接，传输层支持两种通信模式（TCP and UDP )，可以给用户选择的机会，对于简单的“请求-应答”协议特别重要</p></li></ul><p><strong>两种模型的评价</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155624.png" style="zoom:55%;" /><hr><h3 id="网络标准化"><a href="#网络标准化" class="headerlink" title="网络标准化"></a>网络标准化</h3><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210915155751.png" style="zoom:60%;" /><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><p><strong>向网络层（即链路层的上一层）提供的服务种类</strong></p><ol><li>提供面向无连接的服务且不带确认，如以太网（差错率较低的环境）；</li><li>提供面向无连接的服务且带确认，如802.11无线网络（差错率较高）</li><li>带确认的面向连接服务</li></ol><p><strong>成帧方法</strong></p><ol><li>字节计数    2. 带字节填充的首尾定界符法     3. 带比特填充的首尾定界符法    4.  物理层编码违例法</li></ol><p><strong>差错控制</strong><br>如：检错码    前向纠错码    重传机制</p><p><strong>流量控制</strong></p><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><ul><li><p>海明距离的计算</p></li><li><p>最小海明距离和<em>纠错个数</em>，以及<em>查错个数</em>的关系</p><p>海明码编码规则，以及通过海明码来纠正单位错误</p></li></ul><p>**interleaving **编码样式</p><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>奇校验、偶校验        interleaving</p><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>校验和的计算</p><p>例：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211021235948.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211022000006.png"></p><p>前面多出的10加到0100上，相应得到二进制位串，接下去进行取反（0110）取反得到（1001），对应十进制数为9。在进行一波验证：</p><p>如图所示</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20211022000459.png"></p><h4 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h4><h3 id="基本的数据链路层协议"><a href="#基本的数据链路层协议" class="headerlink" title="基本的数据链路层协议"></a>基本的数据链路层协议</h3><p>重点掌握<strong>PAR(Positive Acknowledgement with Retransmission)/ARQ（Automatic Repeat reQuest）方法。</strong></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h3 id="数据链路层协议示例"><a href="#数据链路层协议示例" class="headerlink" title="数据链路层协议示例"></a>数据链路层协议示例</h3><ol><li><strong>HDLC</strong> (High-level Data Link Control)</li></ol><ol start="2"><li><strong>PPP</strong> (Point-to-point Protocol)</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>课内复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP 阅读</title>
    <link href="/2021/09/29/2021-09-16-OSTEP-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/09/29/2021-09-16-OSTEP-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="OSTEP阅读笔记"><a href="#OSTEP阅读笔记" class="headerlink" title="OSTEP阅读笔记"></a>OSTEP阅读笔记</h1><h2 id="进程调度-chapter-7"><a href="#进程调度-chapter-7" class="headerlink" title="进程调度(chapter 7)"></a>进程调度(chapter 7)</h2><h3 id="衡量的调度指标"><a href="#衡量的调度指标" class="headerlink" title="衡量的调度指标"></a>衡量的调度指标</h3><ol><li><p>周转时间</p><p>T周转时间 = T完成时间 - T到达时间</p><p>假设所有任务同时到达，可设到达时间= 0</p></li><li><p>响应时间</p><p>T响应时间= T首次运行- T到达时间</p></li></ol><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>计算周转时间的例子，见下图</p><h3 id="SJF-最短任务优先"><a href="#SJF-最短任务优先" class="headerlink" title="SJF 最短任务优先"></a>SJF 最短任务优先</h3><p>在任务不同时到达时，存在问题。</p><h3 id="STCF-最短完成时间优先"><a href="#STCF-最短完成时间优先" class="headerlink" title="STCF 最短完成时间优先"></a>STCF 最短完成时间优先</h3><p>还有个名字 <em>抢占式最短作业优先</em></p><p>每当新工作进入系统时，就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作</p><p><em>以上的都是针对周转时间的优化方法</em></p><p>接下来是对于响应时间敏感程序的调度</p><hr><h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><p>Round-Robin, RR</p><p>时间片越短，RR在响应时间上表现越好；但是时间片过短，会导致上下文切换的成本过高，影响整体性能。所以系统设计者需要权衡时间片的长度，从而摊销上下文的切换成本。</p><h3 id="如果结合I-O来看……？"><a href="#如果结合I-O来看……？" class="headerlink" title="如果结合I/O来看……？"></a>如果结合I/O来看……？</h3><p>之前的情况都没有结合I/O读写，那么就有了<em>重叠</em>（overlap）操作</p><p>见下图</p><hr><h2 id="多级反馈队列（MLFQ）-chapter-8"><a href="#多级反馈队列（MLFQ）-chapter-8" class="headerlink" title="多级反馈队列（MLFQ）(chapter 8)"></a>多级反馈队列（MLFQ）(chapter 8)</h2><blockquote><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术 （同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶 段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。(OSTEP 第57页)</p></blockquote><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>MLFQ中有很多独立队列，他们有不同的优先级。任何时刻，一个工作只可能存在于一个队列中。MLFQ总是优先执行较高优先级的工作。</p><p>如果一个队列中有多个工作，则使用RR（轮转调度）的方式进行。</p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215215.png" alt="书本P58" style="zoom:100%;" /><h3 id="优化的开始……？"><a href="#优化的开始……？" class="headerlink" title="优化的开始……？"></a>优化的开始……？</h3><h4 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h4><p>工作进入系统时，放入最高优先级；用完整个时间片后，降低优先级（进入别的队列）；如果是在时间片内主动释放CPU，优先级不变（比如时间片内进行I/O读写）</p><p>简单的几个例子：</p><p><strong>单个长工作</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215626.png"></p><p><strong>加了个短工作</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916215742.png"></p><p>将一个新来的任务默认为短任务；并把它置于最高优先级。（长时间的工作，优先级一般都在最底下了……）</p><p>在上图这种情况下，类似于SJF，即最短任务优先的情况；如果说不是一个短任务，其优先级也会逐渐降级。（最后有可能进入队列Q0）</p><p><strong>考虑I/O呢？</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916220239.png" alt="书本P59"></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916220307.png" style="zoom:120%;" /><h3 id="上述方案存在的一些问题"><a href="#上述方案存在的一些问题" class="headerlink" title="上述方案存在的一些问题"></a>上述方案存在的一些问题</h3><ol><li><p>如果遇到很多I/O读取的程序，长时间的程序有可能就没机会使用CPU资源，就饿死了。</p></li><li><p>存在一些程序花里胡哨，使用欺骗手段。<strong>比如说</strong></p><p>​    在一个时间片快结束的时候发起一个I/O读写，从而继续顺利占领最高优先级，达到几乎”独占“使用CPU资源。</p></li></ol><h3 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h3><p>针对之前的一些问题，（比如有工作饿死等等）有了以下的继续尝试</p><h4 id="周期性提升优先级"><a href="#周期性提升优先级" class="headerlink" title="周期性提升优先级"></a>周期性提升优先级</h4><p><img src="C:/Users/Junjie1108/AppData/Roaming/Typora/typora-user-images/image-20210916221158748.png" alt="书本P60"></p><p>当然，仍存在着一些问题……这个时间段S怎么确定下来呢？过长导致长工作仍会”饿“；过短的话，交互性工作得不到合适的CPU时间比例。这个值也被<em>John Ousterhout</em>称为 Voo-doo constant </p><h4 id="进行进程消耗时间的统计"><a href="#进行进程消耗时间的统计" class="headerlink" title="进行进程消耗时间的统计"></a>进行进程消耗时间的统计</h4><p><em>这是之前所提的针对的程序欺骗的情形，所采取的手段</em></p><p>调度程序去记录一个进程在某一个层级所消耗的总时间；而不是调度时重新计时。（这里不管进程是一次性用完的，还是分好几次用完的）</p><p>对比如下图所示</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916221829.png" alt="image-20210916221829365"></p><h3 id="MLFQ调优及其他问题"><a href="#MLFQ调优及其他问题" class="headerlink" title="MLFQ调优及其他问题"></a>MLFQ调优及其他问题</h3><p>……</p><p><em><strong>配置多少队列？队列的时间片配置多大？提升优先级的S时间段大小又怎么定？</strong></em></p><p>……</p><p>其实可以，在高优先级的队列中使用较短的时间片，适合交互工作更快切换；低优先级队列的时间片更长，更适合需要CPU资源的进程进行工作。</p><p>还有些规则使用数学公式计算，期望的估计进行进程优先级的切换。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210916222941.png" alt="书本P63"></p><blockquote><p>MLFQ 以史为鉴：关注进程的一贯表现，然后区别对待。</p><p>操作系统应 尽可能多地使用建议（advice），在进程调度，还有其他的各个领域，也有类似的方式。</p></blockquote><h2 id="比例份额调度"><a href="#比例份额调度" class="headerlink" title="比例份额调度"></a>比例份额调度</h2><h3 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h3><p><em>通过彩票调度，来进行CPU资源的划分；一个进程拥有的彩票数站总彩票书的百分比，就是它占有资源的份额</em></p><blockquote><p>彩票调度的精髓在于：利用随机性。传统的一些算法（比如LRU替换策略），可能在一些负载下表现非常差，但随机方法就不会。</p><p>其次，他很轻量，不需要记录状态，进程运行的时间等等。</p><p>另外，它很快。只要随机数产生的快就行了）</p></blockquote><p><em>如果需要用某种机制来表示所有权比例，这个概念可能就是彩票。</em></p><h3 id="一些机制"><a href="#一些机制" class="headerlink" title="一些机制"></a>一些机制</h3><p>彩票货币；彩票转让；彩票通胀</p><p>彩票货币，见P66</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210918195615.png"></p><p>彩票转让    </p><p>​    一个进程临时将自己的彩票转交给另一个进程；这种机制在Client/Server交互场景中有用。</p><p>​    在这种场景中，客户端进程给服务端发送消息，按自己需求进行工作，为了加速服务端执行，客户端可以选择转让彩票给服务端。服务端执行结束后会将这部分彩票还给客户端。</p><p>彩票通胀</p><p>​    一个机制可以临时提升或降低自己的彩票数量（前天要求进程间相互信任）</p><p>在这种情况下，一个进程知道自己需要更多CPU时间，则可以不与其他进程通信，直接进行与OS的告知。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p></blockquote><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929231657.png" alt="P67"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929231736.png"></p><h3 id="特点-以及-问题"><a href="#特点-以及-问题" class="headerlink" title="特点 以及 问题"></a>特点 以及 问题</h3><p>一个特点：只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。（也就是比较公平）</p><p><strong>问题在于</strong>:到底怎么为工作分配彩票呢？</p><h3 id="新引入：步长调度算法"><a href="#新引入：步长调度算法" class="headerlink" title="新引入：步长调度算法"></a>新引入：步长调度算法</h3><blockquote><p>你可能还想知道，究竟为什么要利用随机性？从上面的内容可以看出，虽然随机方式 可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作 运行时间很短的情况下。由于这个原因，Waldspurger 提出了步长调度（stride scheduling），<br>一个确定性的公平分配算法[W95]。</p></blockquote><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929232322.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929232352.png"></p><p>最终每个进程的运行次数恰好是票数的比例。彩票调度算法只能一段时间后，在概率上实现比例，步长调度算法可以在每个调度周期后做到完全正确。</p><p>但，<strong>彩票调度的优势在于</strong>——不需要全局状态。</p><p>当一个新进程中途进入，步长调度算法对于该新进程，如何设置行程值呢？而彩票调度只需要将票数加入总票数再进行计算即可。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这两种比例份额调度的算法，都没有作为CPU调度程序广泛使用，因为没有对于I/O进行很好的处理。但这种算法在容易确定比例份额的领域更有用（比如虚拟机分配资源）。</p><h2 id="抽象：地址空间"><a href="#抽象：地址空间" class="headerlink" title="抽象：地址空间"></a>抽象：地址空间</h2><h3 id="多道程序和时分共享"><a href="#多道程序和时分共享" class="headerlink" title="多道程序和时分共享"></a>多道程序和时分共享</h3><p>在进程切换的时候，我们将进程信息放在内存中，这样操作系统可以更有效率地实现时分共享。如下图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929233401.png"></p><p>假设只有一个进程，那么操作系统选择运行其中一个进程，其他的进程在队列中等待运行。</p><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210929233521.png"></p><p>虚拟内存的三个主要目标：透明<em>transparency</em>,效率<em>efficiency</em>,保护<em>protection</em></p><p>程序不应感受到内存被虚拟化；操作系统应该保证在时、空两个维度上尽可能高效（在此过程中不得不依靠硬件支持，包括TLB的硬件功能）；保护进程之间互不干扰影响（关键概念：隔离）</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP-动态规划学习（1）</title>
    <link href="/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <url>/2021/09/06/2021-09-06-DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划学习（1）"><a href="#动态规划学习（1）" class="headerlink" title="动态规划学习（1）"></a>动态规划学习（1）</h1><p>我这个铁fw直到要大二了，才开始着手算法部分的复习（其实是学习QAQ）</p><hr><h2 id="动态规划的思考方法"><a href="#动态规划的思考方法" class="headerlink" title="动态规划的思考方法"></a>动态规划的思考方法</h2><p>这一方法来自于AcWing社区的创始人yxc，是y总特别教学的dp问题分析大法</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>例题：AcWing 02，下附链接</p><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><p><strong>题目描述</strong></p><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; N,V &lt;= 1000;    0&lt; Vi , Wi &lt;= 1000;</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改进为一维后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= v[i]; j --)<span class="hljs-comment">//这边进行了一个逆向</span><br>        &#123;<br>        <span class="hljs-comment">//    f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//    if(j &gt;= v[i])</span><br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>&#125;<br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="最大子序列和-ex-Leetcode-53"><a href="#最大子序列和-ex-Leetcode-53" class="headerlink" title="最大子序列和 (ex. Leetcode_53)"></a>最大子序列和 (ex. Leetcode_53)</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="codes-1"><a href="#codes-1" class="headerlink" title="codes:"></a>codes:</h4><p>方法一：（动态规划朴素）</p><p><code>int f[i]</code> 代表以 num[i]为结尾的子序列和，探寻<code>f[i]</code>和<code>f[i-1]</code>的递推关系式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=53 lang=cpp</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [53] 最大子序和</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> MIN = <span class="hljs-number">-1e8</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> f[N];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N ; i ++)    f[i] = MIN;<br><br>        <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        f[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)<br>            f[i] = <span class="hljs-built_in">max</span>(nums[i], f[i<span class="hljs-number">-1</span>] + nums[i]);<br>        <br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1e8</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><p>方法二：    Kadane算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> MIN = <span class="hljs-number">-1e8</span>;<br>    <span class="hljs-keyword">int</span> ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> sig = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i ++)<br>        &#123;<br>            temp += nums[i];<br>            <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">0</span>)<br>                temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(ans &lt; temp)<br>            &#123;<br>                ans = temp;<br>                sig = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!sig)<br>        &#123;<br>            ans = MIN;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i ++)<br>                ans = <span class="hljs-built_in">max</span>(ans, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列和"><a href="#最长上升子序列和" class="headerlink" title="最长上升子序列和"></a>最长上升子序列和</h3><p>相关题目    PAT A1007</p><p>给定一个数字序列A1，A2，A3……An，求i, j，使得Ai + ……+ Aj 最大，输出这个最大值</p><p><strong>输入样例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">10<br><span class="hljs-string">-10</span> 1 2 3 4 <span class="hljs-string">-5</span> <span class="hljs-string">-23</span> 3 7 <span class="hljs-string">-21</span><br>0<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="codes-2"><a href="#codes-2" class="headerlink" title="codes:"></a>codes:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> f[N];<br><span class="hljs-keyword">int</span> s[N];<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>  i = <span class="hljs-number">1</span> ;i &lt;= k ; i ++)<br>            &#123;<br>                cin &gt;&gt; a[i];<br>                <span class="hljs-keyword">if</span>(a[i] &gt;= <span class="hljs-number">0</span>)   flag = <span class="hljs-literal">true</span>;<br>            &#125;    <br> <br>            <span class="hljs-keyword">if</span>(!flag)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[k] &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br> <br>            f[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>] + a[i] &gt; a[i])<br>                &#123;<br>                    f[i] = f[i<span class="hljs-number">-1</span>] + a[i];<br>                    s[i] = s[i<span class="hljs-number">-1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    f[i] = a[i];<br>                    s[i] = i;<br>                &#125;<br>            &#125;<br> <br>            <span class="hljs-keyword">int</span> ind = <span class="hljs-number">0</span>;<br> <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[ind] &lt; f[i])<br>                    ind = i;<br>            &#125;<br> <br>            cout &lt;&lt; f[ind] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[s[ind]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[ind] &lt;&lt; endl; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长不下降子序列（递增子序列）"><a href="#最长不下降子序列（递增子序列）" class="headerlink" title="最长不下降子序列（递增子序列）"></a>最长不下降子序列（递增子序列）</h3><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1≤N,M≤1000</p><p><strong>输入样例</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">abcd</span><br><span class="hljs-attribute">abedc</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h4 id="codes-3"><a href="#codes-3" class="headerlink" title="codes"></a>codes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">char</span> a[N];<br><span class="hljs-keyword">char</span> b[N];<br><span class="hljs-keyword">int</span> n , m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; a+<span class="hljs-number">1</span> &gt;&gt; b+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m ; j ++)<br>       &#123;<br>       f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span>(a[i] == b[j])<br>           f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大写字母。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少操作次数。</p><p><strong>数据范围</strong></p><p>1≤n,m≤1000</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">10 <br>AGTCTGACGC<br>11 <br>AGTAAGTAGGC<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="codes-4"><a href="#codes-4" class="headerlink" title="codes"></a>codes</h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithms</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(4)</title>
    <link href="/2021/08/28/2021-08-28-CPP-OPP-review(4)/"/>
    <url>/2021/08/28/2021-08-28-CPP-OPP-review(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-4"><a href="#CPP-OPP-review-4" class="headerlink" title="CPP-OPP review(4)"></a>CPP-OPP review(4)</h1>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(3)</title>
    <link href="/2021/07/22/2021-07-20-CPP-OPP-review(3)/"/>
    <url>/2021/07/22/2021-07-20-CPP-OPP-review(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-3"><a href="#CPP-OPP-review-3" class="headerlink" title="CPP-OPP review(3)"></a>CPP-OPP review(3)</h1><p>A <strong>BIG THREE</strong>:</p><ol><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>析构 </li></ol><p>有指针成员的函数，必须要有拷贝构造+拷贝赋值  </p><p>否则就产生多重引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __MYSTRING__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __MYSTRING__</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:                                 <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr=<span class="hljs-number">0</span>);                     <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);                    <br>   String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);         <br>   ~<span class="hljs-built_in">String</span>();                                    <br>   <span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (cstr) &#123;<br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//动态分配内存， +1因为包括结束符</span><br>      <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;   <br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];<br>      *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//注意这里是*m_data</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//注意这里是delete[]，而不是delete</span><br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<span class="hljs-comment">//拷贝赋值</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//&amp;符号的含义结合具体情况，加在类型后面就是引用，</span><br>       <span class="hljs-comment">//如果加在变量名前，就是取地址</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这种情况检验自我赋值。例如s1 = s1;</span><br>    <span class="hljs-comment">//特殊情况特殊处理</span><br><br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//先delete，再分配空间+拷贝</span><br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String&amp; str)</span><span class="hljs-comment">//拷贝构造</span></span><br><span class="hljs-function"></span>&#123;<br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br>   os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();<br>   <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723231933.png" alt="构造函数 和 析构函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232041.png" alt="拷贝构造"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232232.png" alt="拷贝赋值函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232327.png" alt="自我赋值造成可能的危险"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232632.png" alt="new 申请空间"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232713.png" alt="delete 释放空间"></p><p><code>new</code>实际上先申请了一部分内存，在进行构造</p><p><code>delete</code>则反过来，先调用析构函数，再释放内存</p><hr><p>接下来是底层的内存分配示意图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233051.png"></p><p>红色部分是 <em>cookie</em>，各占四个字节；灰色部分是 <em>debugger header</em>，以及<em>no man land</em>，当然还有内存对齐所需要的空间。    从52到64，是为了让申请的内存块大小达到16Byte的倍数。</p><p>之后的图片说明了，<code>delete</code>和<code>delete[]</code>的区别：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233633.png" alt="delete的使用"></p><p>确实会造成<strong>memory leak</strong>，但其实是打<strong>？！</strong>的内存区域没有被回收，而不是想象中的<strong>21h</strong>部分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(2)</title>
    <link href="/2021/07/20/2021-07-20-CPP-OPP-review(2)/"/>
    <url>/2021/07/20/2021-07-20-CPP-OPP-review(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-2"><a href="#CPP-OPP-review-2" class="headerlink" title="CPP-OPP review(2)"></a>CPP-OPP review(2)</h1><ol><li><p>操作符重载，可分为：<strong>成员函数</strong>（含<code>this</code>指针）和<strong>非成员函数</strong>。</p></li><li><p>临时对象，例如之前所写的<code>complex</code>类,<code>complex(2,1)</code>创建一个**2 + i *<em>的复数临时对象。如果在成员函数当中被临时创建，注意使用</em>return by value*, 因为在函数中创建的对象是 <em>local</em> 的，临时的。</p></li><li><p>输入输出流作为参数不可以作为<code>const</code>传入</p></li><li><p>一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么返回的是<code>ostream&amp;</code>，而不是<code>void</code>？</p><p>因为很常见的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; c1;<span class="hljs-comment">//void 还是ostream&amp;返回 都可以</span><br>cout &lt;&lt; c1 &lt;&lt; c2;<span class="hljs-comment">//假设是这种情况，void返回就不行。</span><br></code></pre></td></tr></table></figure><hr></li></ol><p><strong>总结</strong></p><p><strong>initialization list</strong>的使用；函数参数考虑，尽量用<em>pass_by_reference</em>；函数参数考虑是否要加<code>const</code>；函数返回值考虑是否用<em>pass_by_reference</em>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(1)</title>
    <link href="/2021/07/18/2021-07-18-CPP-0PP-review(1)/"/>
    <url>/2021/07/18/2021-07-18-CPP-0PP-review(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-1"><a href="#CPP-OPP-review-1" class="headerlink" title="CPP-OPP review(1)"></a>CPP-OPP review(1)</h1><p>这个<em>review</em>系列是本人观看侯捷老师的面向对象的讲解视频，并结合 <em>effective C++</em> 这本经典书籍，进行的一些知识点的零散记录。</p><hr><ol><li><p>class中的成员函数，默认成为<code>inline</code>函数的候选</p></li><li><p>外部的函数想要成为<code>inline</code>，需要加关键字<code>inline</code></p></li><li><p>构造函数的写法：</p><ol><li><p>赋值写法</p></li><li><p>运用<strong>初值列</strong>(<em>initialization list</em>),进行初始化</p><p>这两种的区别是，构造函数先进行初始化，再进行{}内部的操作，用<em>initialization list</em>更有效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re, im;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>构造函数允许有很多个 - <strong>overloading</strong></p><p><em>但如果出现以下的例子，则not allowed</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<span class="hljs-comment">//这里不需要加分号了</span><br><span class="hljs-built_in">complex</span>():<span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>)&#123;&#125;<span class="hljs-comment">//与上面一个构造函数冲突</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">double</span> re, im;<br></code></pre></td></tr></table></figure></li><li><p>构造函数也有可能写在<code>private</code>中，这种模式叫做<em>singleton</em>.</p></li><li><p>在写成员函数的时候，就需要考虑好，是否需要加上<code>const</code>.<strong>该加上就要加上！</strong></p></li><li><p>尽可能多用<em>pass-by-reference</em>，pass-by-value(to const)需要将数据 <em>打包</em> 压入栈，（可能爆栈）</p></li><li><p>相同<code>class</code>的各个对象互为友元，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex &amp;pra)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (pra.re + pra.im);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re , im;<br>&#125;;<br><br><span class="hljs-comment">//////////以下为main函数///////</span><br>&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    c2.<span class="hljs-built_in">func</span>(c1);<span class="hljs-comment">//实部虚部相加 </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/12_随记</title>
    <link href="/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-12-随记"><a href="#CPP-面向对象-21-7-12-随记" class="headerlink" title="CPP 面向对象 21/7/12 随记"></a>CPP 面向对象 21/7/12 随记</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>使用了<code>new</code>或指针的相同类或结构体的对象间，不能使用 = 进行赋值操作，必须对 = 进行了操作符重载后，才能赋值。否则两个类的指针指向相同的内存地址。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>分为<code>public</code>继承和<code>private</code>继承 （还有<code>protected</code>继承）</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210713082837.png"></p><p>派生类的访问权限由基类+继承类型 <em>取小</em> 得到。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超频一时爽，系统崩溃死机火葬场</title>
    <link href="/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/"/>
    <url>/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="这周末的作死，让我对OverClock产生了阴影……"><a href="#这周末的作死，让我对OverClock产生了阴影……" class="headerlink" title="这周末的作死，让我对OverClock产生了阴影……"></a>这周末的作死，让我对OverClock产生了阴影……</h1><p>另外自己也不应该买es的CPU，在bios自检不通过的情况下，也没有妥善处理。</p><p>感谢msi，感谢Intel，感谢巨硬。也感谢    <strong>自己作大死！</strong></p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/8_随记</title>
    <link href="/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-07-08"><a href="#CPP-面向对象-21-07-08" class="headerlink" title="CPP 面向对象  21/07/08"></a>CPP 面向对象  21/07/08</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ol><li><p> <code>enum</code> <strong>枚举类型变量</strong></p></li><li><p><code>struct</code><strong>类型</strong></p><p>对于<code>struct</code>整体进行操作，可行的有：</p><ol><li>给同一<code>struct</code>类型的对象赋值（值传递或引用传递）</li><li>作为函数参数返回</li></ol></li><li><p><code>class</code><strong>类型</strong></p><ol><li><p>该类型中有两种成员： 数据成员 和 函数成员</p></li><li><p>成员默认为<code>private</code>，这一点和<code>struct</code>类型不同</p></li><li><p>函数成员大多应该声明为public类型</p></li><li><p><code>private</code>类型成员无法被外部访问，只能被该<code>class</code>成员函数 和 友元 访问</p></li><li><p>（默认）构造函数</p></li></ol></li></ol><hr><p><em>以下更新于2021.7.9</em></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><blockquote><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><p>内联函数一般用于能够快速执行的函数，对于很小的函数也有空间上的溢出。</p><p>内联函数是在函数原型的前面加上<code>inline</code>限定符, 例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt; y)?x:y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(20,10): &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(100,1010)： &quot;</span>&lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1010</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><p>内联函数是为了解决函数调用的效率问题。编译的时候，调用式用函数体进行替换；而其他的函数都是在运行的时候才被替代。    故实际上是通过<strong>空间换时间</strong>。以下有几个注意点：</p><ol><li>循环语句，开关语句不允许出现</li><li>内联函数的定义，需要出现在函数第一次调用之前</li><li>类结构中所在的类说明内部定义的函数是内联函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++》 阅读随记</title>
    <link href="/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读《Effective-C-》第一章"><a href="#读《Effective-C-》第一章" class="headerlink" title="读《Effective C++》第一章"></a>读《Effective C++》第一章</h1><h2 id="C-是一个语言联邦"><a href="#C-是一个语言联邦" class="headerlink" title="C++是一个语言联邦"></a>C++是一个语言联邦</h2><p>C++是一个多重范型(muitiparidigm)语言，其支持：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>次语言(sublanguage)：C, Object-Oriented C++, Template C++, STL</p><p>正因如此，高效编程需要随着编程者切换次语言来采取不同的守则、通例。</p><h2 id="用-const-enum-inline-替换-define"><a href="#用-const-enum-inline-替换-define" class="headerlink" title="用 const enum inline 替换 #define"></a>用 <code>const</code> <code>enum</code> <code>inline</code> 替换 <code>#define</code></h2><ol><li><p>对于常量</p><p>例如：<code>#define ASPECT_RATIO 1.653</code> 该记号名称也许从未被编译器看见，很可能在编译器处理源码之前，就被预处理器移走。这样的后果：ASPECT_RATIO 有可能未进入 symbol table （<em><strong>注：符号表等概念可以查阅CSAPP第七章</strong></em>）。于是一旦发生编译错误，可能就因此让编程者产生困惑。</p><p>解决方法：用常量替换一个上述的宏</p></li></ol><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708142830.png" style="zoom:80%;" /><p>​        两种特殊情况：</p><p>​        <strong>常量指针</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143130.png" style="zoom:80%;" /><p>​        <strong><code>class</code>专属常量</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143415.png" style="zoom:80%;" /><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143755.png" style="zoom:80%;" /><p>​        <strong>enum hack</strong> 技术，能够避免出现可能的（编译器不够优秀）为“整数型const对象” 进行内存分配</p><p>​        <strong>enum hack</strong> 技术，是模板元编程的基础技术。</p><ol start="2"><li>用<code>inline</code> 替代macro</li></ol><p>（暂时略……）</p><p><strong>总结</strong></p><blockquote><p>对于单纯常量，最好以const对象 或 enum 替换 #define</p><p>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</p></blockquote><h2 id="尽可能使用-const"><a href="#尽可能使用-const" class="headerlink" title="尽可能使用 const"></a>尽可能使用 <code>const</code></h2><p><code>const</code>关键字允许指定一个语义约束（说人话就是指定一个改动不了的对象）</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190027.png"></p><p><strong><code>const</code> 若出现在星号左边，表示被指物为常量；在星号右边，表示指针是常量；如果星号两边都有<code>const</code>,说明被指对象和指针本身都是常量。</strong></p><p>注：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190839.png"></p><hr><p>对于STL迭代器的<code>const</code>，和命名指针(T类型的指针, <code>T*</code>)类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// iter的作用类似于 T* const</span><br><span class="hljs-comment">//指向的东西必须一样，但东西的值可以改变</span><br>*iter = <span class="hljs-number">10</span>;<span class="hljs-comment">//ok</span><br>iter ++;<span class="hljs-comment">//not allowed</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// cIter的作用类似于 const T*  </span><br><span class="hljs-comment">//被指向的东西不得改变</span><br>*cIter = <span class="hljs-number">10</span>;<span class="hljs-comment">//not allowed</span><br>cIter ++;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>令函数返回一个常量值，往往可以能够降低因client端的错误而造成的意外。详细例子见书P19</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>这类函数重要，原因有两个：</p><ol><li><p>让class接口更好理解，client端知道哪个函数可以改变对象内容，而哪个不行。</p></li><li><p>让操作<code>const</code>对象成为可能，因为提升C++程序效率的一条原则：<em><strong>pass by reference to const</strong></em></p><p>这技术可行的前提：有<code>const</code>成员函数用来处理取得的<code>const</code>对象</p></li></ol><p>一个事实：如果两个函数只是常量性不同，可以被重载。</p><p>如图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215257.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215407.png"></p><p>因为<code>non-const operator[]</code>的返回类型是<strong>reference to char</strong>，不是<code>char</code>；如果返回的是<code>char</code>，该语句无法通过编译。因为函数如果返回类型是内置类型（如<code>int</code>,<code>char</code>,<code>bool</code>）, 改动返回值就是不合法的。</p><hr><p>还有两个概念<strong>logical constness</strong> 和 <strong>bitwise constness</strong> </p><p>后者支持者认为成员函数只有在不改变认为成员变量（除静态<code>static</code>变量以外）的情况下，才可以被称为<code>const</code>.</p><p>也就是不改动任何一个<strong>bit</strong>. 但却有很多函数符合该规则，却不是十足具备<code>const</code>性质，如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220107.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220127.png"></p><p>另一派支持：**<code>const</code>成员函数可以修改对象的某些bits，但要在客户端侦测不到的时候才得如此。**</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220438.png"></p><p>重要： <strong>用<code>mutable</code>“骗过”编译器</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220501.png"></p><h3 id="在const-和-non-const成员函数中避免重复"><a href="#在const-和-non-const成员函数中避免重复" class="headerlink" title="在const 和 non-const成员函数中避免重复"></a>在const 和 non-const成员函数中避免重复</h3><p><em>暂时略……反正<code>const</code>很强就完事了……</em></p><p><strong>总结：</strong></p><blockquote><p>将有些东西声明为<code>const</code>可以帮助编译器侦测出错误用法。 <code>const</code>可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><p>编译器强制实施 <strong>bitwise constness</strong>, 但实际编写程序应该使用“概念上的常量性”（比如使用mutable）</p><p>用<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>版本调用<code>const</code>版本可避免代码的重复。</p></blockquote><h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>《Effective C++》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/7_随记</title>
    <link href="/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-7"><a href="#CPP-面向对象-21-7-7" class="headerlink" title="CPP 面向对象 21/7/7"></a>CPP 面向对象 21/7/7</h1><h2 id="库-lt-fstream-gt-的使用，文件输入输出"><a href="#库-lt-fstream-gt-的使用，文件输入输出" class="headerlink" title="库&lt;fstream&gt;的使用，文件输入输出"></a>库<code>&lt;fstream&gt;</code>的使用，文件输入输出</h2><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-comment">/*...省略其余头文件...*/</span><br><br><span class="hljs-keyword">double</span> a;<br>string b;<br><span class="hljs-comment">//需要读入的变量</span><br><br>ifstream inFile;<br>ofstream outFile;<br><br>inFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;INPUT.txt&quot;</span>);<span class="hljs-comment">//此处为相对路径</span><br>outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;result.txt&quot;</span>);<span class="hljs-comment">//结果输出到 result.txt 文件中</span><br><br>inFile &gt;&gt; a &gt;&gt; b;<span class="hljs-comment">//读入</span><br><span class="hljs-comment">//同理输出到文件用outFile</span><br><br><span class="hljs-comment">/*关于文件流的使用，可以用 inFile,outFile 代替原有的 cin,cout*/</span><br><br>inFile.<span class="hljs-built_in">close</span>();<br>outFile.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭流</span><br><br><br></code></pre></td></tr></table></figure><p>如果输入流打开的文件有误（读取不合法，或文件路径错误等等），会产生输入流的挂起。这种情况在编写程序的时候需要特判    如<code>if(!inFile)  return 1;</code></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Don&#39;t program with COINCIDENCE.</title>
    <link href="/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/"/>
    <url>/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/6_随记</title>
    <link href="/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-6"><a href="#CPP-面向对象-21-7-6" class="headerlink" title="CPP 面向对象 21/7/6"></a>CPP 面向对象 21/7/6</h1><h2 id="C-语法知识"><a href="#C-语法知识" class="headerlink" title="C++语法知识"></a>C++语法知识</h2><p><strong>格式化输出setw(), setprecision()应用</strong></p><p>setw() 默认右对齐</p><p>eg. s和a之间有7个空格，cout&lt;&lt;’s’&lt;&lt;setw(8)&lt;&lt;’a’&lt;&lt;endl;的意思是s后面输出8个字符，其中a占一个字符，剩余7个字符用空格填充</p><p>setw()默认用空格填充，也可以用其他的字符填充，运用setfill()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">21</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706102918153.png"></p><p>如果需要左对齐，则在前面添加left，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &lt;&lt;  <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706104131423.png"></p><hr><p>setprecision() + fixed 控制精确到小数点后的位数</p><p><em><strong>补充：setfill()函数会永久更改填充空格的字符，下次重新用的时候注意初始化为所用的符号（默认的setw()填充为空格）</strong></em></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>类具有封装和信息隐藏的特性。只有<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">类的成员函数</a>才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a>，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。 </p><p>为了解决上述问题，提出一种使用友元的方案。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。(from baidu)</p></blockquote><ol><li><strong>友元函数</strong></li></ol><p>友元是定义在类外部的普通函数或类，但需要在<em><strong>类体中</strong></em>进行说明，用<code>friend</code>关键字加以说明。故友元函数的调用不需要对象表示，直接调用即可。</p><p>友元函数没有this指针，其参数分几种情况：</p><p>访问非static变量，需要对象作为参数；访问static成员或全局变量时，不需要对象做参数。</p><ol start="2"><li><strong>友元类</strong></li></ol><blockquote><p>友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的<a href="https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a>，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p></blockquote><p>格式：</p><p><code>friend class  </code> + 类名</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706131141197.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
