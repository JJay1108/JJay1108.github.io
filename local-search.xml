<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/8_随记</title>
    <link href="/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-07-08"><a href="#CPP-面向对象-21-07-08" class="headerlink" title="CPP 面向对象  21/07/08"></a>CPP 面向对象  21/07/08</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ol><li><p> <code>enum</code> <strong>枚举类型变量</strong></p></li><li><p><code>struct</code><strong>类型</strong></p><p>对于<code>struct</code>整体进行操作，可行的有：</p><ol><li>给同一<code>struct</code>类型的对象赋值（值传递或引用传递）</li><li>作为函数参数返回</li></ol></li><li><p><code>class</code><strong>类型</strong></p><ol><li><p>该类型中有两种成员： 数据成员 和 函数成员</p></li><li><p>成员默认为<code>private</code>，这一点和<code>struct</code>类型不同</p></li><li><p>函数成员大多应该声明为public类型</p></li><li><p><code>private</code>类型成员无法被外部访问，只能被该<code>class</code>成员函数 和 友元 访问</p></li><li><p>（默认）构造函数</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++》 阅读随记</title>
    <link href="/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读《Effective-C-》第一章"><a href="#读《Effective-C-》第一章" class="headerlink" title="读《Effective C++》第一章"></a>读《Effective C++》第一章</h1><h2 id="C-是一个语言联邦"><a href="#C-是一个语言联邦" class="headerlink" title="C++是一个语言联邦"></a>C++是一个语言联邦</h2><p>C++是一个多重范型(muitiparidigm)语言，其支持：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>次语言(sublanguage)：C, Object-Oriented C++, Template C++, STL</p><p>正因如此，高效编程需要随着编程者切换次语言来采取不同的守则、通例。</p><h2 id="用-const-enum-inline-替换-define"><a href="#用-const-enum-inline-替换-define" class="headerlink" title="用 const enum inline 替换 #define"></a>用 <code>const</code> <code>enum</code> <code>inline</code> 替换 <code>#define</code></h2><ol><li><p>对于常量</p><p>例如：<code>#define ASPECT_RATIO 1.653</code> 该记号名称也许从未被编译器看见，很可能在编译器处理源码之前，就被预处理器移走。这样的后果：ASPECT_RATIO 有可能未进入 symbol table （<em><strong>注：符号表等概念可以查阅CSAPP第七章</strong></em>）。于是一旦发生编译错误，可能就因此让编程者产生困惑。</p><p>解决方法：用常量替换一个上述的宏</p></li></ol><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708142830.png" style="zoom:80%;" /><p>​        两种特殊情况：</p><p>​        <strong>常量指针</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143130.png" style="zoom:80%;" /><p>​        <strong><code>class</code>专属常量</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143415.png" style="zoom:80%;" /><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143755.png" style="zoom:80%;" /><p>​        <strong>enum hack</strong> 技术，能够避免出现可能的（编译器不够优秀）为“整数型const对象” 进行内存分配</p><p>​        <strong>enum hack</strong> 技术，是模板元编程的基础技术。</p><ol start="2"><li>用<code>inline</code> 替代macro</li></ol><p>（暂时略……）</p><p><strong>总结</strong></p><blockquote><p>对于单纯常量，最好以const对象 或 enum 替换 #define</p><p>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</p></blockquote><h2 id="尽可能使用-const"><a href="#尽可能使用-const" class="headerlink" title="尽可能使用 const"></a>尽可能使用 <code>const</code></h2><p><code>const</code>关键字允许指定一个语义约束（说人话就是指定一个改动不了的对象）</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190027.png"></p><p><strong><code>const</code> 若出现在星号左边，表示被指物为常量；在星号右边，表示指针是常量；如果星号两边都有<code>const</code>,说明被指对象和指针本身都是常量。</strong></p><p>注：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190839.png"></p><hr><p>对于STL迭代器的<code>const</code>，和命名指针(T类型的指针, <code>T*</code>)类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// iter的作用类似于 T* const</span><br><span class="hljs-comment">//指向的东西必须一样，但东西的值可以改变</span><br>*iter = <span class="hljs-number">10</span>;<span class="hljs-comment">//ok</span><br>iter ++;<span class="hljs-comment">//not allowed</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// cIter的作用类似于 const T*  </span><br><span class="hljs-comment">//被指向的东西不得改变</span><br>*cIter = <span class="hljs-number">10</span>;<span class="hljs-comment">//not allowed</span><br>cIter ++;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>令函数返回一个常量值，往往可以能够降低因client端的错误而造成的意外。详细例子见书P19</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>这类函数重要，原因有两个：</p><ol><li><p>让class接口更好理解，client端知道哪个函数可以改变对象内容，而哪个不行。</p></li><li><p>让操作<code>const</code>对象成为可能，因为提升C++程序效率的一条原则：<em><strong>pass by reference to const</strong></em></p><p>这技术可行的前提：有<code>const</code>成员函数用来处理取得的<code>const</code>对象</p></li></ol><p>一个事实：如果两个函数只是常量性不同，可以被重载。</p><p>如图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215257.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215407.png"></p><p>因为<code>non-const operator[]</code>的返回类型是<strong>reference to char</strong>，不是<code>char</code>；如果返回的是<code>char</code>，该语句无法通过编译。因为函数如果返回类型是内置类型（如<code>int</code>,<code>char</code>,<code>bool</code>）, 改动返回值就是不合法的。</p><hr><p>还有两个概念<strong>logical constness</strong> 和 <strong>bitwise constness</strong> </p><p>后者支持者认为成员函数只有在不改变认为成员变量（除静态<code>static</code>变量以外）的情况下，才可以被称为<code>const</code>.</p><p>也就是不改动任何一个<strong>bit</strong>. 但却有很多函数符合该规则，却不是十足具备<code>const</code>性质，如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220107.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220127.png"></p><p>另一派支持：**<code>const</code>成员函数可以修改对象的某些bits，但要在客户端侦测不到的时候才得如此。**</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220438.png"></p><p>重要： <strong>用<code>mutable</code>“骗过”编译器</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220501.png"></p><h3 id="在const-和-non-const成员函数中避免重复"><a href="#在const-和-non-const成员函数中避免重复" class="headerlink" title="在const 和 non-const成员函数中避免重复"></a>在const 和 non-const成员函数中避免重复</h3>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>《Effective C++》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/7_随记</title>
    <link href="/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-7"><a href="#CPP-面向对象-21-7-7" class="headerlink" title="CPP 面向对象 21/7/7"></a>CPP 面向对象 21/7/7</h1><h2 id="库-lt-fstream-gt-的使用，文件输入输出"><a href="#库-lt-fstream-gt-的使用，文件输入输出" class="headerlink" title="库&lt;fstream&gt;的使用，文件输入输出"></a>库<code>&lt;fstream&gt;</code>的使用，文件输入输出</h2><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-comment">/*...省略其余头文件...*/</span><br><br><span class="hljs-keyword">double</span> a;<br>string b;<br><span class="hljs-comment">//需要读入的变量</span><br><br>ifstream inFile;<br>ofstream outFile;<br><br>inFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;INPUT.txt&quot;</span>);<span class="hljs-comment">//此处为相对路径</span><br>outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;result.txt&quot;</span>);<span class="hljs-comment">//结果输出到 result.txt 文件中</span><br><br>inFile &gt;&gt; a &gt;&gt; b;<span class="hljs-comment">//读入</span><br><span class="hljs-comment">//同理输出到文件用outFile</span><br><br><span class="hljs-comment">/*关于文件流的使用，可以用 inFile,outFile 代替原有的 cin,cout*/</span><br><br>inFile.<span class="hljs-built_in">close</span>();<br>outFile.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭流</span><br><br><br></code></pre></td></tr></table></figure><p>如果输入流打开的文件有误（读取不合法，或文件路径错误等等），会产生输入流的挂起。这种情况在编写程序的时候需要特判    如<code>if(!inFile)  return 1;</code></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Don&#39;t program with COINCIDENCE.</title>
    <link href="/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/"/>
    <url>/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/6_随记</title>
    <link href="/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-6"><a href="#CPP-面向对象-21-7-6" class="headerlink" title="CPP 面向对象 21/7/6"></a>CPP 面向对象 21/7/6</h1><h2 id="C-语法知识"><a href="#C-语法知识" class="headerlink" title="C++语法知识"></a>C++语法知识</h2><p><strong>格式化输出setw(), setprecision()应用</strong></p><p>setw() 默认右对齐</p><p>eg. s和a之间有7个空格，cout&lt;&lt;’s’&lt;&lt;setw(8)&lt;&lt;’a’&lt;&lt;endl;的意思是s后面输出8个字符，其中a占一个字符，剩余7个字符用空格填充</p><p>setw()默认用空格填充，也可以用其他的字符填充，运用setfill()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">21</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706102918153.png"></p><p>如果需要左对齐，则在前面添加left，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &lt;&lt;  <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706104131423.png"></p><hr><p>setprecision() + fixed 控制精确到小数点后的位数</p><p><em><strong>补充：setfill()函数会永久更改填充空格的字符，下次重新用的时候注意初始化为所用的符号（默认的setw()填充为空格）</strong></em></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>类具有封装和信息隐藏的特性。只有<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">类的成员函数</a>才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a>，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。 </p><p>为了解决上述问题，提出一种使用友元的方案。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。(from baidu)</p></blockquote><ol><li><strong>友元函数</strong></li></ol><p>友元是定义在类外部的普通函数或类，但需要在<em><strong>类体中</strong></em>进行说明，用<code>friend</code>关键字加以说明。故友元函数的调用不需要对象表示，直接调用即可。</p><p>友元函数没有this指针，其参数分几种情况：</p><p>访问非static变量，需要对象作为参数；访问static成员或全局变量时，不需要对象做参数。</p><ol start="2"><li><strong>友元类</strong></li></ol><blockquote><p>友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的<a href="https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a>，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p></blockquote><p>格式：</p><p><code>friend class  </code> + 类名</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706131141197.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/05/hello-world/"/>
    <url>/2021/07/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
