<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPP-OPP review(2)</title>
    <link href="/2021/07/20/2021-07-20-CPP-OPP-review(2)/"/>
    <url>/2021/07/20/2021-07-20-CPP-OPP-review(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-2"><a href="#CPP-OPP-review-2" class="headerlink" title="CPP-OPP review(2)"></a>CPP-OPP review(2)</h1><ol><li><p>操作符重载，可分为：<strong>成员函数</strong>（含<code>this</code>指针）和<strong>非成员函数</strong>。</p></li><li><p>临时对象，例如之前所写的<code>complex</code>类,<code>complex(2,1)</code>创建一个**2 + i *<em>的复数临时对象。如果在成员函数当中被临时创建，注意使用</em>return by value*, 因为在函数中创建的对象是 <em>local</em> 的，临时的。</p></li><li><p>输入输出流作为参数不可以作为<code>const</code>传入</p></li><li><p>一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么返回的是<code>ostream&amp;</code>，而不是<code>void</code>？</p><p>因为很常见的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; c1;<span class="hljs-comment">//void 还是ostream&amp;返回 都可以</span><br>cout &lt;&lt; c1 &lt;&lt; c2;<span class="hljs-comment">//假设是这种情况，void返回就不行。</span><br></code></pre></td></tr></table></figure><hr></li></ol><p><strong>总结</strong></p><p><strong>initialization list</strong>的使用；函数参数考虑，尽量用<em>pass_by_reference</em>；函数参数考虑是否要加<code>const</code>；函数返回值考虑是否用<em>pass_by_reference</em>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(3)</title>
    <link href="/2021/07/20/2021-07-20-CPP-OPP-review(3)/"/>
    <url>/2021/07/20/2021-07-20-CPP-OPP-review(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-3"><a href="#CPP-OPP-review-3" class="headerlink" title="CPP-OPP review(3)"></a>CPP-OPP review(3)</h1><p>A<strong>BIG THREE</strong>:</p><ol><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>析构 </li></ol><p>有指针成员的函数，必须要有拷贝构造+拷贝赋值  </p><p>否则就产生多重引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __MYSTRING__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __MYSTRING__</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:                                 <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr=<span class="hljs-number">0</span>);                     <br>   <span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);                    <br>   String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);         <br>   ~<span class="hljs-built_in">String</span>();                                    <br>   <span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (cstr) &#123;<br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//动态分配内存， +1因为包括结束符</span><br>      <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;   <br>      m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];<br>      *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//注意这里是*m_data</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//注意这里是delete[]，而不是delete</span><br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<span class="hljs-comment">//拷贝赋值</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//&amp;符号的含义结合具体情况，加在类型后面就是引用，</span><br>       <span class="hljs-comment">//如果加在变量名前，就是取地址</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这种情况检验自我赋值。例如s1 = s1;</span><br>    <span class="hljs-comment">//特殊情况特殊处理</span><br><br>   <span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//先delete，再分配空间+拷贝</span><br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String&amp; str)</span><span class="hljs-comment">//拷贝构造</span></span><br><span class="hljs-function"></span>&#123;<br>   m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];<br>   <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br>   os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();<br>   <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723231933.png" alt="构造函数 和 析构函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232041.png" alt="拷贝构造"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232232.png" alt="拷贝赋值函数"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232327.png" alt="自我赋值造成可能的危险"></p><hr><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232632.png" alt="new 申请空间"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723232713.png" alt="delete 释放空间"></p><p><code>new</code>实际上先申请了一部分内存，在进行构造</p><p><code>delete</code>则反过来，先调用析构函数，再释放内存</p><hr><p>接下来是底层的内存分配示意图</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233051.png"></p><p>红色部分是 <em>cookie</em>，各占四个字节；灰色部分是 <em>debugger header</em>，以及<em>no man land</em>，当然还有内存对齐所需要的空间。    从52到64，是为了让申请的内存块大小达到16Byte的倍数。</p><p>之后的图片说明了，<code>delete</code>和<code>delete[]</code>的区别：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210723233633.png" alt="delete的使用"></p><p>确实会造成<strong>memory leak</strong>，但其实是打<strong>？！</strong>的内存区域没有被回收，而不是想象中的<strong>21h</strong>部分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP-OPP review(1)</title>
    <link href="/2021/07/18/2021-07-18-CPP-0PP-review(1)/"/>
    <url>/2021/07/18/2021-07-18-CPP-0PP-review(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-OPP-review-1"><a href="#CPP-OPP-review-1" class="headerlink" title="CPP-OPP review(1)"></a>CPP-OPP review(1)</h1><p>这个<em>review</em>系列是本人观看侯捷老师的面向对象的讲解视频，并结合 <em>effective C++</em> 这本经典书籍，进行的一些知识点的零散记录。</p><hr><ol><li><p>class中的成员函数，默认成为<code>inline</code>函数的候选</p></li><li><p>外部的函数想要成为<code>inline</code>，需要加关键字<code>inline</code></p></li><li><p>构造函数的写法：</p><ol><li><p>赋值写法</p></li><li><p>运用<strong>初值列</strong>(<em>initialization list</em>),进行初始化</p><p>这两种的区别是，构造函数先进行初始化，再进行{}内部的操作，用<em>initialization list</em>更有效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re, im;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>构造函数允许有很多个 - <strong>overloading</strong></p><p><em>但如果出现以下的例子，则not allowed</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)<br>        &#123;&#125;<span class="hljs-comment">//这里不需要加分号了</span><br><span class="hljs-built_in">complex</span>():<span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>)&#123;&#125;<span class="hljs-comment">//与上面一个构造函数冲突</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">double</span> re, im;<br></code></pre></td></tr></table></figure></li><li><p>构造函数也有可能写在<code>private</code>中，这种模式叫做<em>singleton</em>.</p></li><li><p>在写成员函数的时候，就需要考虑好，是否需要加上<code>const</code>.<strong>该加上就要加上！</strong></p></li><li><p>尽可能多用<em>pass-by-reference</em>，pass-by-value(to const)需要将数据 <em>打包</em> 压入栈，（可能爆栈）</p></li><li><p>相同<code>class</code>的各个对象互为友元，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex &amp;pra)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (pra.re + pra.im);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> re , im;<br>&#125;;<br><br><span class="hljs-comment">//////////以下为main函数///////</span><br>&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    c2.<span class="hljs-built_in">func</span>(c1);<span class="hljs-comment">//实部虚部相加 </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/12_随记</title>
    <link href="/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/12/2021-07-12-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_21712_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-12-随记"><a href="#CPP-面向对象-21-7-12-随记" class="headerlink" title="CPP 面向对象 21/7/12 随记"></a>CPP 面向对象 21/7/12 随记</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>使用了<code>new</code>或指针的相同类或结构体的对象间，不能使用 = 进行赋值操作，必须对 = 进行了操作符重载后，才能赋值。否则两个类的指针指向相同的内存地址。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>分为<code>public</code>继承和<code>private</code>继承 （还有<code>protected</code>继承）</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210713082837.png"></p><p>派生类的访问权限由基类+继承类型 <em>取小</em> 得到。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超频一时爽，系统崩溃死机火葬场</title>
    <link href="/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/"/>
    <url>/2021/07/12/2021-07-12-%E8%B6%85%E9%A2%91%E4%B8%80%E6%97%B6%E7%88%BD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%AD%BB%E6%9C%BA%E7%81%AB%E8%91%AC%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="这周末的作死，让我对OverClock产生了阴影……"><a href="#这周末的作死，让我对OverClock产生了阴影……" class="headerlink" title="这周末的作死，让我对OverClock产生了阴影……"></a>这周末的作死，让我对OverClock产生了阴影……</h1><p>另外自己也不应该买es的CPU，在bios自检不通过的情况下，也没有妥善处理。</p><p>感谢msi，感谢Intel，感谢巨硬。也感谢    <strong>自己作大死！</strong></p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/8_随记</title>
    <link href="/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/08/2021-07-08-CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2178_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-07-08"><a href="#CPP-面向对象-21-07-08" class="headerlink" title="CPP 面向对象  21/07/08"></a>CPP 面向对象  21/07/08</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ol><li><p> <code>enum</code> <strong>枚举类型变量</strong></p></li><li><p><code>struct</code><strong>类型</strong></p><p>对于<code>struct</code>整体进行操作，可行的有：</p><ol><li>给同一<code>struct</code>类型的对象赋值（值传递或引用传递）</li><li>作为函数参数返回</li></ol></li><li><p><code>class</code><strong>类型</strong></p><ol><li><p>该类型中有两种成员： 数据成员 和 函数成员</p></li><li><p>成员默认为<code>private</code>，这一点和<code>struct</code>类型不同</p></li><li><p>函数成员大多应该声明为public类型</p></li><li><p><code>private</code>类型成员无法被外部访问，只能被该<code>class</code>成员函数 和 友元 访问</p></li><li><p>（默认）构造函数</p></li></ol></li></ol><hr><p><em>以下更新于2021.7.9</em></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><blockquote><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><p>内联函数一般用于能够快速执行的函数，对于很小的函数也有空间上的溢出。</p><p>内联函数是在函数原型的前面加上<code>inline</code>限定符, 例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt; y)?x:y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(20,10): &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max(100,1010)： &quot;</span>&lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1010</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><p>内联函数是为了解决函数调用的效率问题。编译的时候，调用式用函数体进行替换；而其他的函数都是在运行的时候才被替代。    故实际上是通过<strong>空间换时间</strong>。以下有几个注意点：</p><ol><li>循环语句，开关语句不允许出现</li><li>内联函数的定义，需要出现在函数第一次调用之前</li><li>类结构中所在的类说明内部定义的函数是内联函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++》 阅读随记</title>
    <link href="/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/08/Effective-C++-%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读《Effective-C-》第一章"><a href="#读《Effective-C-》第一章" class="headerlink" title="读《Effective C++》第一章"></a>读《Effective C++》第一章</h1><h2 id="C-是一个语言联邦"><a href="#C-是一个语言联邦" class="headerlink" title="C++是一个语言联邦"></a>C++是一个语言联邦</h2><p>C++是一个多重范型(muitiparidigm)语言，其支持：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>次语言(sublanguage)：C, Object-Oriented C++, Template C++, STL</p><p>正因如此，高效编程需要随着编程者切换次语言来采取不同的守则、通例。</p><h2 id="用-const-enum-inline-替换-define"><a href="#用-const-enum-inline-替换-define" class="headerlink" title="用 const enum inline 替换 #define"></a>用 <code>const</code> <code>enum</code> <code>inline</code> 替换 <code>#define</code></h2><ol><li><p>对于常量</p><p>例如：<code>#define ASPECT_RATIO 1.653</code> 该记号名称也许从未被编译器看见，很可能在编译器处理源码之前，就被预处理器移走。这样的后果：ASPECT_RATIO 有可能未进入 symbol table （<em><strong>注：符号表等概念可以查阅CSAPP第七章</strong></em>）。于是一旦发生编译错误，可能就因此让编程者产生困惑。</p><p>解决方法：用常量替换一个上述的宏</p></li></ol><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708142830.png" style="zoom:80%;" /><p>​        两种特殊情况：</p><p>​        <strong>常量指针</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143130.png" style="zoom:80%;" /><p>​        <strong><code>class</code>专属常量</strong></p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143415.png" style="zoom:80%;" /><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708143755.png" style="zoom:80%;" /><p>​        <strong>enum hack</strong> 技术，能够避免出现可能的（编译器不够优秀）为“整数型const对象” 进行内存分配</p><p>​        <strong>enum hack</strong> 技术，是模板元编程的基础技术。</p><ol start="2"><li>用<code>inline</code> 替代macro</li></ol><p>（暂时略……）</p><p><strong>总结</strong></p><blockquote><p>对于单纯常量，最好以const对象 或 enum 替换 #define</p><p>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</p></blockquote><h2 id="尽可能使用-const"><a href="#尽可能使用-const" class="headerlink" title="尽可能使用 const"></a>尽可能使用 <code>const</code></h2><p><code>const</code>关键字允许指定一个语义约束（说人话就是指定一个改动不了的对象）</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190027.png"></p><p><strong><code>const</code> 若出现在星号左边，表示被指物为常量；在星号右边，表示指针是常量；如果星号两边都有<code>const</code>,说明被指对象和指针本身都是常量。</strong></p><p>注：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708190839.png"></p><hr><p>对于STL迭代器的<code>const</code>，和命名指针(T类型的指针, <code>T*</code>)类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// iter的作用类似于 T* const</span><br><span class="hljs-comment">//指向的东西必须一样，但东西的值可以改变</span><br>*iter = <span class="hljs-number">10</span>;<span class="hljs-comment">//ok</span><br>iter ++;<span class="hljs-comment">//not allowed</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// cIter的作用类似于 const T*  </span><br><span class="hljs-comment">//被指向的东西不得改变</span><br>*cIter = <span class="hljs-number">10</span>;<span class="hljs-comment">//not allowed</span><br>cIter ++;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>令函数返回一个常量值，往往可以能够降低因client端的错误而造成的意外。详细例子见书P19</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>这类函数重要，原因有两个：</p><ol><li><p>让class接口更好理解，client端知道哪个函数可以改变对象内容，而哪个不行。</p></li><li><p>让操作<code>const</code>对象成为可能，因为提升C++程序效率的一条原则：<em><strong>pass by reference to const</strong></em></p><p>这技术可行的前提：有<code>const</code>成员函数用来处理取得的<code>const</code>对象</p></li></ol><p>一个事实：如果两个函数只是常量性不同，可以被重载。</p><p>如图：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215257.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708215407.png"></p><p>因为<code>non-const operator[]</code>的返回类型是<strong>reference to char</strong>，不是<code>char</code>；如果返回的是<code>char</code>，该语句无法通过编译。因为函数如果返回类型是内置类型（如<code>int</code>,<code>char</code>,<code>bool</code>）, 改动返回值就是不合法的。</p><hr><p>还有两个概念<strong>logical constness</strong> 和 <strong>bitwise constness</strong> </p><p>后者支持者认为成员函数只有在不改变认为成员变量（除静态<code>static</code>变量以外）的情况下，才可以被称为<code>const</code>.</p><p>也就是不改动任何一个<strong>bit</strong>. 但却有很多函数符合该规则，却不是十足具备<code>const</code>性质，如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220107.png"></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220127.png"></p><p>另一派支持：**<code>const</code>成员函数可以修改对象的某些bits，但要在客户端侦测不到的时候才得如此。**</p><p>例如：</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220438.png"></p><p>重要： <strong>用<code>mutable</code>“骗过”编译器</strong></p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/20210708220501.png"></p><h3 id="在const-和-non-const成员函数中避免重复"><a href="#在const-和-non-const成员函数中避免重复" class="headerlink" title="在const 和 non-const成员函数中避免重复"></a>在const 和 non-const成员函数中避免重复</h3><p><em>暂时略……反正<code>const</code>很强就完事了……</em></p><p><strong>总结：</strong></p><blockquote><p>将有些东西声明为<code>const</code>可以帮助编译器侦测出错误用法。 <code>const</code>可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><p>编译器强制实施 <strong>bitwise constness</strong>, 但实际编写程序应该使用“概念上的常量性”（比如使用mutable）</p><p>用<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>版本调用<code>const</code>版本可避免代码的重复。</p></blockquote><h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>《Effective C++》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/7_随记</title>
    <link href="/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/07/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2177_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-7"><a href="#CPP-面向对象-21-7-7" class="headerlink" title="CPP 面向对象 21/7/7"></a>CPP 面向对象 21/7/7</h1><h2 id="库-lt-fstream-gt-的使用，文件输入输出"><a href="#库-lt-fstream-gt-的使用，文件输入输出" class="headerlink" title="库&lt;fstream&gt;的使用，文件输入输出"></a>库<code>&lt;fstream&gt;</code>的使用，文件输入输出</h2><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-comment">/*...省略其余头文件...*/</span><br><br><span class="hljs-keyword">double</span> a;<br>string b;<br><span class="hljs-comment">//需要读入的变量</span><br><br>ifstream inFile;<br>ofstream outFile;<br><br>inFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;INPUT.txt&quot;</span>);<span class="hljs-comment">//此处为相对路径</span><br>outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;result.txt&quot;</span>);<span class="hljs-comment">//结果输出到 result.txt 文件中</span><br><br>inFile &gt;&gt; a &gt;&gt; b;<span class="hljs-comment">//读入</span><br><span class="hljs-comment">//同理输出到文件用outFile</span><br><br><span class="hljs-comment">/*关于文件流的使用，可以用 inFile,outFile 代替原有的 cin,cout*/</span><br><br>inFile.<span class="hljs-built_in">close</span>();<br>outFile.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭流</span><br><br><br></code></pre></td></tr></table></figure><p>如果输入流打开的文件有误（读取不合法，或文件路径错误等等），会产生输入流的挂起。这种情况在编写程序的时候需要特判    如<code>if(!inFile)  return 1;</code></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Don&#39;t program with COINCIDENCE.</title>
    <link href="/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/"/>
    <url>/2021/07/06/2021-7-6-Dont-program-with-COINCIDENCE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPP_面向对象_21/7/6_随记</title>
    <link href="/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/"/>
    <url>/2021/07/06/CPP_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_2176_%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-面向对象-21-7-6"><a href="#CPP-面向对象-21-7-6" class="headerlink" title="CPP 面向对象 21/7/6"></a>CPP 面向对象 21/7/6</h1><h2 id="C-语法知识"><a href="#C-语法知识" class="headerlink" title="C++语法知识"></a>C++语法知识</h2><p><strong>格式化输出setw(), setprecision()应用</strong></p><p>setw() 默认右对齐</p><p>eg. s和a之间有7个空格，cout&lt;&lt;’s’&lt;&lt;setw(8)&lt;&lt;’a’&lt;&lt;endl;的意思是s后面输出8个字符，其中a占一个字符，剩余7个字符用空格填充</p><p>setw()默认用空格填充，也可以用其他的字符填充，运用setfill()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">21</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706102918153.png"></p><p>如果需要左对齐，则在前面添加left，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &lt;&lt;  <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706104131423.png"></p><hr><p>setprecision() + fixed 控制精确到小数点后的位数</p><p><em><strong>补充：setfill()函数会永久更改填充空格的字符，下次重新用的时候注意初始化为所用的符号（默认的setw()填充为空格）</strong></em></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>类具有封装和信息隐藏的特性。只有<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">类的成员函数</a>才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a>，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。 </p><p>为了解决上述问题，提出一种使用友元的方案。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。(from baidu)</p></blockquote><ol><li><strong>友元函数</strong></li></ol><p>友元是定义在类外部的普通函数或类，但需要在<em><strong>类体中</strong></em>进行说明，用<code>friend</code>关键字加以说明。故友元函数的调用不需要对象表示，直接调用即可。</p><p>友元函数没有this指针，其参数分几种情况：</p><p>访问非static变量，需要对象作为参数；访问static成员或全局变量时，不需要对象做参数。</p><ol start="2"><li><strong>友元类</strong></li></ol><blockquote><p>友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的<a href="https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a>，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p></blockquote><p>格式：</p><p><code>friend class  </code> + 类名</p><p><img src="https://gitee.com/jasonstudyield/imagesbed/raw/master/image-20210706131141197.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/05/hello-world/"/>
    <url>/2021/07/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
