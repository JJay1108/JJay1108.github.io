---
title: DP-动态规划学习（1）
date: 2021-09-06
tags: 
- algorithms
- Dynamic Programming
---

# 动态规划学习（1）



我这个铁fw直到要大二了，才开始着手算法部分的复习（其实是学习QAQ）



----

## 动态规划的思考方法

这一方法来自于AcWing社区的创始人yxc，是y总特别教学的dp问题分析大法

## 背包问题

### 01 背包

例题：AcWing 02，下附链接

[2. 01背包问题 - AcWing题库](https://www.acwing.com/problem/content/2/)

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0 < N,V <= 1000;	0< Vi , Wi <= 1000;

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**

```
8
```

##### codes

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1e3 + 10;
int n, m;
int v[N];
int w[N];
int f[N][N];

int main()
{
	cin >> n >> m;
    
    for(int i = 1; i <= n ; i ++)
        cin >> v[i] >> w[i];
   	
    for(int i = 1; i <= n ; i ++)
        for(int j = 0; j <= m; j ++)
        {
            f[i][j] = f[i - 1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
		}
    cout << f[n][m] << endl;
    
    return 0;
}
```

**改进为一维后：**

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1e3 + 10;
int n, m;
int v[N];
int w[N];
int f[N];

int main()
{
	cin >> n >> m;
    
    for(int i = 1; i <= n ; i ++)
        cin >> v[i] >> w[i];
   	
    for(int i = 1; i <= n ; i ++)
        for(int j = m; j >= v[i]; j --)//这边进行了一个逆向
        {
        //    f[i][j] = f[i - 1][j];
        //    if(j >= v[i])
                f[j] = max(f[j], f[j - v[i]] + w[i]);
		}		
    cout << f[m] << endl;
    return 0;
}
```



